<SYSTEM>This is the full developer documentation for Atlas Starter | React Native Template</SYSTEM>

# Perfect React Native App Kickstart ğŸš€!

> Your All-in-One Solution for Building Outstanding React Native/Expo Apps. From editor setup to store submission, we've got you covered!

[ | Give us a star on Github ](https://github.com/obytes/react-native-template-obytes)

## Features

[Section titled â€œFeaturesâ€](#features)

Latest Expo SDK + Dev Client

We utilize the most recent Expo SDK and React Native version, along with a custom development client feature, to guarantee that you can install any package and retain full control over your app.

Expo Router

The latest version of Expo Router comes pre-installed and includes examples that demonstrate how to implement comprehensive navigation within your app.

10+ GitHub workflows

From running type checks, tests, lint checks, and code formatting to generating a new app version, and building your app using EAS Build, already configured and ready to go!

Minimal UI kit with Tailwind CSS

Weâ€™ve included a minimal UI with most of the components youâ€™ll need to get started with your project. Itâ€™s built using Tailwind CSS and is very easy to customize.

VSCode Setup

A complete list of recommended extensions, settings, and snippets for Visual Studio Code (VSCode) that enhance the developer experience and boost productivity.

TS + Eslint + Prettier + Husky

We use TypeScript, Eslint, Prettier, and Husky to ensure that your code is clean and consistent. No more worrying about code style or pushing bad code!

Fully Documented

Weâ€™ve included a comprehensive set of documentation to help you get started with your project and understand our choices and decisions.

Multiple environment builds support

Multiple app environments with a robust solution to manage and validate environment variables with Zod. It enables easy switching between different environments throughout the development and deployment processes.

Form and Keyboard Handling

We use React Hook Form for form management and Zod for validation, along with a set of inputs for your app. We also include keyboard handling to provide a seamless user experience.

Auth Flow

We have included a complete authentication flow based on Zustand as a state management library and `react-native-mmkv` as a secure and fast solution for storing tokens and other sensitive data.

React Query + Axios

We manage data fetching using React Query and Axios. These powerful libraries make it easy to fetch, cache, and update data in your React applications. We also include a set of VSCode snippets to make your life easier when creating queries and mutations.

Unit + E2E tests

We provide a complete setup for unit and end-to-end tests using Jest and React Testing Library, along with Meastro for end-to-end testing. This will assist you in writing tests for your app and ensuring that it functions as expected.

### Trusted by React Native Developers Worldwide

Developers love our starter! Check out what they're saying:

One of the **best starter apps** that feel complete to get started creating your Expo and React Native app. It's rare to see a project keeping up with the latest developments in the React Native world in a fast-changing environment, **production-ready** at the same time, and with such clear documentation around it.\
**Hats off to the Obytes team** for creating it and actively maintaining it!

![Aman Mittal](/reviews//aman.jpg)

**Aman Mittal** Docs Maintainer @Expo

The **best React Native starter project ever!** ğŸ”¥\
I'm a React Native developer with more than 5 years of experience and I've seen a lot of React Native projects, templates and boilerplates but this is the **best one**. Here we have all of the steps to build an app from scratch to production.\
The section that I really **love** is the Environment Variables, you make the really great way to handling this, guys!\
Thank u all ğŸ©¶

![Yuri P. Baumgartner](/reviews//yuri.jpeg)

**Yuri P. Baumgartner** React Native Developer

This template combines all the latest React and React Native **best practices** in one powerful starter. Combined with additional GitHub actions to build your app, this is one of the most future-proof React Native templates - and itâ€™s even **free!**

![Simon](/reviews/simon.jpg)

**Simon** Founder @Galaxies\_dev

This boilerplate has everything needed to build a robust mobile app. It **saves a lot of time** and I highly recommend ğŸ‘Œ

![Kawtar CHOUBARI](/reviews//kawtar.jpg)

**Kawtar CHOUBARI** React/React Native Developer

**You guys are life savers!**

![Brandon Eichhorn](/reviews//brandon.png)

**Brandon Eichhorn** Developer

[Love the template? Let us know â­ï¸](https://github.com/obytes/react-native-template-obytes/discussions/357)

Built with â¤ï¸ by Obytes

In addition to maintaining this starter kit, we provide expertise in custom projects and app development. If youâ€™re looking for experienced and reliable developers to bring your app vision to life, reach out to us. Letâ€™s discuss your project and explore how we can help you achieve your goals.

[Hire Us](https://obytes.com/contact?utm_source=starter.obytes.com)

# CHANGELOG

> New features, improvements, and bug fixes for the React Native / Expo Starter.

For complete changelog, please check the [GitHub releases](https://github.com/obytes/react-native-template-obytes/releases) page.

# App releasing process

> How to release your app to the App Store and Google Play

Releasing your app to the App Store and Google Play or even to your QA team for real testing is a very important step in the app development process. Internally, we tend to release a new version of the app to our QA team by the end of each sprint(every week or two weeks). This way, we can get feedback from our team and test the app on real devices.

Doing this in a weekly basis requires automating the process as much as possible to gain time and avoid a lot of manual work.

To make this process as easy as possible, we use Github action and expo eas to build and release our app to the App Store and Google Play.

## The Philosophy

[Section titled â€œThe Philosophyâ€](#the-philosophy)

The philosophy behind this process is to have a single task that you should trigger to build and distribute the app. This task should be triggered manually by any developer on the team.

The main idea is that we focus on the QA release process and push a new release to the QA team whenever our team pushes a new release to GitHub (at the end of the sprint). Whenever we feel that we are ready to push a new release to the App Store and Google Play, we can trigger a production release manually from the master branch or from the last GitHub release tag that has already been pushed to the QA team.

In conclusion, we have two types of releases:

* **QA release**: This release is triggered automatically whenever a new github release is created. This release is used to distribute the app to the QA team for testing.

* **Production release**: This release is triggered manually whenever we want to push a new release to the App Store and Google Play and can be build it based on the last GitHub release tag or from the master branch.

Note

We aim to simplify the process as much as possible. Depending on your requirements, you can take inspiration from this process and modify it to meet your needs.

## The Process

[Section titled â€œThe Processâ€](#the-process)

The starter comes with a set of tools and tricks that help make the process as easy as possible.

### `app-release` npm script

[Section titled â€œapp-release npm scriptâ€](#app-release-npm-script)

A simple npm script that run np package that helps us to manage the version of the app and push a new tag to GitHub.

```json
{
  "scripts": {
    "app-release": "cross-env SKIP_BRANCH_PROTECTION=true np --no-publish --no-cleanup --no-release-draft",
    "version": "pnpm run prebuild && git add ."
  }
}
```

If you run `pnpm run app-release`, it will ask you to choose the type of release (major, minor, patch). based on the type of release, it will update the version inside `package.json`.

As we use the version from package.json as app version inside `app-config.ts`, we just need to run the prebuild script to update App version inside the `ios` and `android` folders. The prebuild script will be executed automatically using a `version` script inside `package.json` that will handle the task for us. It will also add the changes to the commit that will be pushed to GitHub and create a new tag with the version number.

So technically, we just need to run `pnpm run app-release` and it will handle the rest for us. from updating native app version to pushing a new tag to GitHub.

### GitHub actions and Expo EAS workflows

[Section titled â€œGitHub actions and Expo EAS workflowsâ€](#github-actions-and-expo-eas-workflows)

The starter comes with a set of GitHub workflows that use EXPO EAS to build and distribute the app to the App Store and Google Play.

* `new-app-version.yml` : A workflow that run `app-release` script in order to update the app version and push a new tag to GitHub.

* `new-github-release.yml` : A workflow that is triggered whenever a new tag is pushed to GitHub. It will create a new GitHub release based on the tag name with the correct changelog.

* `eas-build-qa.yml` : A workflow that is triggered whenever a new release is created on GitHub. It will build the app using EXPO EAS and based on the config it will distribute.

* `eas-build-prod.yml` : A workflow that is triggered manually whenever we want to push a new release to the App Store and Google Play. It will build the app using EXPO EAS and based on the config it will distribute.

In conclusion, when you want to release a new QA version, manually execute `new-app-version.yml` with the correct release type. After successful execution, `new-github-release.yml` will be triggered automatically, followed by the automatic execution of `eas-build-qa.yml`. This will distribute the app to the QA team.

## Setup Release Process to your app

[Section titled â€œSetup Release Process to your appâ€](#setup-release-process-to-your-app)

To setup the release process to your app, you need to follow these steps:

### Run Build Locally

[Section titled â€œRun Build Locallyâ€](#run-build-locally)

First, make sure to create an [Expo](expo.dev) account then create a new organization for your project.

When then name of your organization is ready, you need to update the `EXPO_ACCOUNT_OWNER` variable in `env.js` file with the name of your organization.

**For QA release:**

```bash
pnpm run prebuild:staging
```

The above command will regenerate the iOS and Android folders based on the `staging` configuration.

Then run the following command to build the app using EAS:

Caution

You need to be logged in to EAS using `eas login` command before running this command. check [step 1 and 2 from EAS docs](https://docs.expo.dev/build/setup/) for more details.

```bash
pnpm run build:staging:ios
pnpm run build:staging:android
```

The above commands will generate the required credentials for the build and store them in EAS servers so that we can use them later to trigger the build from GitHub actions.

**For production release:**

```bash
pnpm run prebuild:production
pnpm run build:production:ios
pnpm run build:production:android
```

In case you want to submit the app to the App Store and Google Play, you need to check eas submit configuration and follow the steps from [EAS docs](https://docs.expo.dev/submit/introduction/).

### Setup GitHub Actions

[Section titled â€œSetup GitHub Actionsâ€](#setup-github-actions)

All github workflows are already ready to be used in the starter. You just need to add the required secrets to your GitHub repo:

* GH\_TOKEN: A [Github token](https://github.com/settings/tokens) with access to your repo.

* EXPO\_TOKEN: Expo token to authenticate with EAS. You can get generate yours [here](https://expo.dev/settings/access-tokens)

### Github action and env variables

[Section titled â€œGithub action and env variablesâ€](#github-action-and-env-variables)

For simplicity, we assume that all your environment variables are already added to your env files and have been pushed to your repository.

If you prefer not to push env files (recommended), you need to add all your environment variables to GitHub secrets. Then, use `create-envfile` action to create the env file on the fly before the prebuild script.

```yaml
## .github/workflows/eas-build-prod.yml


- name: Create envfile
  uses: SpicyPizza/create-envfile@v2.0
  with:
    envkey_DEBUG: false
    envkey_SECRET_KEY: ${{ secrets.PRODUCTION_SECRET_KEY }}
    file_name: .env.production


- name: â±ï¸ EAS Build
  uses: ./.github/actions/eas-build
  with:
    APP_ENV: production
    EXPO_TOKEN: ${{ secrets.EXPO_TOKEN }}
```

This action will create a new env file `.env.production` with the `DEBUG` and `SECRET_KEY` variables you added to the action. so make sure to include all your env variables to the action.

## Create new release

[Section titled â€œCreate new releaseâ€](#create-new-release)

For QA release, Go to your GitHub repo actions tab and run `new-app-version` workflow with the your desired release type.

![new-app-version](https://github.com/obytes/react-native-template-obytes/assets/11137944/efc62eda-a465-44ab-a185-860cfd2e9099)

After successful execution, a new tag will be pushed to master and then `new-github-release` workflow will be triggered automatically and create a github release based on the tag name with the correct changelog.

![new-github-release](https://github.com/obytes/react-native-template-obytes/assets/11137944/d3b9d8ff-37f8-4551-97c1-4c9fbc8860d3)

After that, `eas-build-qa` workflow will be triggered automatically and build the app using EAS and distribute it to the QA team.

For production release, Go to your GitHub repo actions tab and run `eas-build-prod` workflow manually.

```plaintext
```

# Overview

> All you need to know about the CI/CD of the starter.

CI/CD stands for Continuous Integration and Continuous Delivery/Deployment. It is a set of practices that help developers automate the process of building, testing, and distributing applications to end-users (such as app stores for mobile apps).

Having a good CI/CD process in place is crucial for any project, as it helps you save time and effort, as well as ensuring that you are delivering a high-quality product to your users. It helps avoid common mistakes and bugs, reduces your time to market, and allows for faster updates to your users.

As most of our projects are hosted on GitHub, we use [GitHub Actions](https://github.com/features/actions) and [Expo EAS](https://expo.dev/eas) as our CI/CD solution. The starter kit comes with over 10 GitHub Actions workflows:

* `.github/workflows/lint-ts.yml`: On PR and new commits on the master branch, run linting and formatting checks.
* `.github/workflows/test.yml`: On PR and new commits on the master branch, run unit tests.
* `.github/workflows/type-check.yml`: On PR and new commits on the master branch, run type checking.
* `.github/workflows/compress-images.yml`: On new commits to the master branch, when adding images, open a pull request (PR) with the compressed images.
* `.github/workflows/expo-doctor.yml`: On PR and new commits to the master branch, check whether dependencies are aligned with the Expo SDK version.
* `.github/workflows/new-app-version.yml`: A workflow to manually trigger and update the app version, and publish a tag.

You can check the full list of workflows [here](/ci-cd/workflows-references/)

Pushing the new release to the stores is a weekly process for our team. To make it easier, we have created a simple process using GitHub Actions and Expo EAS. You can check the full guide [here](/ci-cd/app-releasing-process/).

# Github Action workflows

> A list of all the Github Action workflows that come with the starter and how to use them.

The starter comes with over 10 GitHub Actions workflows that help you automate the process of checking, testing, releasing, and much more.

All those workflows are self-documented and contain all details directly inside the workflow file as comments. This approach makes it easier to understand what each workflow does and how to use it without having to go back and forth between the documentation and the workflow file.

This page lists all workflows and actions we use and adds more details on the approach we are using to make those workflows as simple as possible.

All files related to GitHub Actions are located in the `.github/workflows` and `.github/actions` folders.

## Actions

[Section titled â€œActionsâ€](#actions)

You can think of actions as functions that are used by workflows to perform a specific task and allow you to reuse the same task in multiple workflows without duplicating the code which made them easier to maintain.

All actions are located in the `.github/actions` folder, and here is the complete list:

### âš™ï¸ Node setup and PNM install

[Section titled â€œâš™ï¸ Node setup and PNM installâ€](#ï¸-node-setup-and-pnm-install)

.github/actions/setup-node-pnpm-install/action.yml

```yml
# ğŸ”— Links:
# Source file: https://github.com/obytes/react-native-template-obytes/blob/master/.github/actions/setup-node-pnpm-install/action.yml
# Composite actions docs: https://docs.github.com/en/actions/creating-actions/creating-a-composite-action


# âœï¸ Description:
# This is a composite action, which means it can be used in other actions.
# It is used in almost all workflows to set up the environment and install dependencies.
# Updating  the package manager or Node version here will be reflected in all workflows.


# ğŸ‘€ Example usage:
#       - name : ğŸ“¦ Setup Node + PNPM + install deps
#         uses: ./.github/actions/setup-node-pnpm-install


name: 'Setup  Node + PNPM + Install Dependencies'
description: 'Setup  Node + PNPM + Install Dependencies'
runs:
  using: 'composite'
  steps:
    - uses: pnpm/action-setup@v4
      with:
        run_install: false
    - uses: actions/setup-node@v4
      with:
        node-version: 20
        cache: 'pnpm'


    - name: ğŸ“¦ Install Project Dependencies
      run: pnpm install --frozen-lockfile
      shell: bash
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

### âš™ï¸ Setup JDK && Generate APK

[Section titled â€œâš™ï¸ Setup JDK && Generate APKâ€](#ï¸-setup-jdk--generate-apk)

.github/actions/setup-jdk-generate-apk/action.yml

```yml
# ğŸ”— Links:
# Source file: https://github.com/obytes/react-native-template-obytes/blob/master/.github/actions/setup-jdk-generate-apk/action.yml
# Composite actions docs: https://docs.github.com/en/actions/creating-actions/creating-a-composite-action


# âœï¸ Description:
# This is a composite action, which means it can be used in other actions.
# This action is used to set up the JDK environment and generate an Android APK for testing.
# This action accepts one input: `APP_ENV`, which is used to generate an APK for a specific environment (development, staging, production). We use staging by default.
# Before generating the APK, we run a pre-build script to generate the necessary native folders based on the APP_ENV.
# On success, the APK is generated at `./android/app/build/outputs/apk/release/app-release.apk`.


# ğŸ‘€ Example usage:
#       - name : ğŸ“¦ Set Up JDK + Generate Test APK
#         uses: ./.github/actions/setup-jdk-generate-apk
#         with:
#           APP_ENV: 'staging'


name: 'Setup  JDK + GRADLE + Generate APK'
description: 'Setup  JDK + GRADLE + Generate APK'
inputs:
  APP_ENV:
    description: 'APP_ENV (one of): development, staging, production'
    required: true
    default: 'staging'


runs:
  using: 'composite'
  steps:
    - name: Set Up JDK
      uses: actions/setup-java@v3
      with:
        distribution: 'zulu' # See 'Supported distributions' for available options
        java-version: '17'
    - name: Setup Gradle
      uses: gradle/gradle-build-action@v2


    - name: Generate Test APK
      run: |
        pnpm prebuild:${{ inputs.APP_ENV }}
        cd  android
        chmod +x ./gradlew
        ./gradlew assembleRelease --no-daemon
        cd ..
      shell: bash
      env:
        EXPO_NO_DOTENV: '1'
        APP_ENV: ${{ inputs.APP_ENV }}
        CI: 'true'
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

### âš™ï¸ EAS Build

[Section titled â€œâš™ï¸ EAS Buildâ€](#ï¸-eas-build)

.github/actions/eas-build/action.yml

```yml
# ğŸ”— Links:
# Source file: https://github.com/obytes/react-native-template-obytes/blob/master/.github/actions/eas-build/action.yml
# EAS Build docs: https://docs.expo.dev/eas-update/github-actions/


# âœï¸ Description:
# This is a composite action, which means it can be used in other actions.
# This action is used to trigger an EAS Build for a specific environment (development, staging, production).
# This action accepts those inputs:
#        `APP_ENV`, which is used to generate an APK for a specific environment (development, staging, production). We use staging by default.
#        `AUTO_SUBMIT`, false by default, set to true if you want to automatically submit your build to stores.
#        `EXPO_TOKEN`, required, access token for your Expo account. https://expo.dev/settings/access-tokens
#        `VERSION`, required, version of the app to build. used as the build message.
#        `ANDROID`, true by default, set to true if you don't want to trigger build for Android.
#        `IOS`, false by default, set to true if you  want to trigger build for IOS.


# Before triggering the build, we run a pre-build script to generate the necessary native folders based on the APP_ENV.
# Based on the ANDROID and IOS inputs, we trigger the build for the corresponding platform with the corresponding flags.


# ğŸ‘€ Example usage:
#      - name: â±ï¸ EAS Build
#        uses: ./.github/actions/eas-build
#        with:
#          APP_ENV: staging
#          EXPO_TOKEN: ${{ secrets.EXPO_TOKEN }}
#          VERSION: ${{ github.event.release.tag_name }}
#          IOS: false


name: 'Setup EAS Build + Trigger Build'
description: 'Setup EAS Build + Trigger Build'
inputs:
  APP_ENV:
    description: 'APP_ENV (one of): development, staging, production'
    required: true
    default: 'staging'
  AUTO_SUBMIT: ## TODO: we need to handle this too
    description: 'AUTO_SUBMIT (one of): true, false'
    required: true
    default: 'false'
  ANDROID:
    description: 'run for ANDROID (one of): true, false'
    required: true
    default: 'true'
  VERSION:
    description: 'VERSION'
    required: true
    default: '0.0.0'
  IOS:
    description: 'run for IOS (one of): true, false'
    required: true
    default: 'false'
  EXPO_TOKEN:
    description: 'EXPO_TOKEN'
    required: true
    default: 'false'


runs:
  using: 'composite'
  steps:
    - name: ğŸ’¯ Check for EXPO_TOKEN
      run: |
        if [ -z "${{ inputs.EXPO_TOKEN }}" ]; then
          echo "You must provide an EXPO_TOKEN secret linked to this project's Expo account in this repo's secrets. Learn more: https://docs.expo.dev/eas-update/github-actions"
          exit 1
        fi
      shell: bash


    - name: ğŸ“¦ Setup Expo and EAS
      uses: expo/expo-github-action@v8
      with:
        eas-version: latest
        token: ${{ inputs.EXPO_TOKEN }}


    - name: âš™ï¸ Run Prebuild
      run: pnpm prebuild:${{ inputs.APP_ENV }}
      shell: bash


    - name: ğŸ“± Run Android Build
      if: ${{ inputs.ANDROID == 'true' }}
      run: pnpm build:${{ inputs.APP_ENV }}:android --non-interactive  --no-wait --message "Build  ${{ inputs.APP_ENV }} ${{ inputs.VERSION }}"
      shell: bash


    - name: ğŸ“± Run IOS Build
      if: ${{ inputs.IOS == 'true' }}
      run: pnpm build:${{ inputs.APP_ENV }}:ios --non-interactive  --no-wait --message "Build ${{ inputs.APP_ENV }} ${{ inputs.VERSION }}"
      shell: bash
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

## Workflows

[Section titled â€œWorkflowsâ€](#workflows)

### âš™ï¸ Linting and formatting

[Section titled â€œâš™ï¸ Linting and formattingâ€](#ï¸-linting-and-formatting)

.github/workflows/lint-ts.yml

```yml
# ğŸ”— Links:
# Source file: https://github.com/leanhtuan1994/react-native-template-atlas/blob/master/.github/workflows/lint-ts.yml


# âœï¸ Description:
# This action is used to run eslint checks
# Runs on pull requests and pushes to  the main/master branches
# Based on the event type:
#   - If it's a pull request, it will run eslint, then add the check to the PR as well as annotate the code with the errors and warnings.
#   - If it's a push to main/master, it will run the type checking and fail if there are any errors.


# ğŸš¨ GITHUB SECRETS REQUIRED: NONE


name: Lint TS (eslint, prettier)


on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]


permissions:
  contents: read
  pull-requests: write


jobs:
  lint:
    name: Lint TS (eslint, prettier)
    runs-on: ubuntu-latest


    steps:
      - name: ğŸ“¦ Checkout project repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0


      - name: ğŸ“¦ Setup Node + PNPM + install deps
        uses: ./.github/actions/setup-node-pnpm-install


      - name: ğŸƒâ€â™‚ï¸ Run ESLint PR
        if: github.event_name == 'pull_request'
        uses: reviewdog/action-eslint@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          reporter: github-pr-review
          eslint_flags: '. --ext .js,.jsx,.ts,.tsx'


      - name: ğŸƒâ€â™‚ï¸ Run ESLint PR
        if: github.event_name != 'pull_request'
        run: pnpm run lint
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

### âš™ï¸ Type checking

[Section titled â€œâš™ï¸ Type checkingâ€](#ï¸-type-checking)

.github/workflows/type-check.yml

```yml
# ğŸ”— Links:
# Source file: https://github.com/leanhtuan1994/react-native-template-atlas/blob/master/.github/workflows/type-check.yml


# âœï¸ Description:
# This action is used to run the type-check on the project.
# Runs on pull requests and pushes to  the main/master branches
# Based on the event type:
#   - If it's a pull request, it will run type checking, then add the check to the PR as well as annotate the code with the errors using reviewdog.
#   - If it's a push to main/master, it will run the type checking and fail if there are any errors.


# ğŸš¨ GITHUB SECRETS REQUIRED: NONE


name: Type Check (tsc)


on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]


permissions:
  contents: read
  pull-requests: write


jobs:
  type-check:
    name: Type Check (tsc)
    runs-on: ubuntu-latest
    steps:
      - name: ğŸ“¦ Checkout project repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0


      - name: ğŸ“¦ Setup Node + PNPM + install deps
        uses: ./.github/actions/setup-node-pnpm-install


      - name: ğŸ“¦ Install Reviewdog
        if: github.event_name == 'pull_request'
        uses: reviewdog/action-setup@v1


      - name: ğŸƒâ€â™‚ï¸ Run TypeScript PR # Reviewdog tsc errorformat: %f:%l:%c - error TS%n: %m
        # We only need to add the reviewdog step if it's a pull request
        if: github.event_name == 'pull_request'
        run: |
          pnpm type-check | reviewdog -name="tsc" -efm="%f(%l,%c): error TS%n: %m" -reporter="github-pr-review" -filter-mode="nofilter" -fail-on-error -tee
        env:
          REVIEWDOG_GITHUB_API_TOKEN: ${{ secrets.GITHUB_TOKEN }}


      - name:
          ğŸƒâ€â™‚ï¸ Run TypeScript Commit
          # If it's not a Pull Request then we just need to run the type-check
        if: github.event_name != 'pull_request'
        run: pnpm type-check
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

### âš™ï¸ Expo Doctor

[Section titled â€œâš™ï¸ Expo Doctorâ€](#ï¸-expo-doctor)

.github/workflows/expo-doctor.yml

```yml
# ğŸ”— Links:
# Source file: https://github.com/leanhtuan1994/react-native-template-atlas/blob/master/.github/workflows/expo-doctor.yml


# âœï¸ Description:
# This workflow runs the expo doctor command to check if your project dependencies are aligned with the expo sdk version you are using.
# Can be triggered manually from the Actions tab in your project.
# Runs Also on pull requests and pushes to the main/master branch, but only if the `package.json` or `pnpm-lock.yaml` files have been changed.


# ğŸš¨ GITHUB SECRETS REQUIRED: NONE


name: Expo Doctor (expo)


on:
  push:
    branches:
      - main
      - master
    paths:
      - 'package.json'
      - 'pnpm-lock.yaml'
  pull_request:
    paths:
      - 'package.json'
      - 'pnpm-lock.yaml'


permissions:
  contents: read
  pull-requests: write


jobs:
  doctor:
    name: Expo Doctor (expo)
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write


    steps:
      - name: ğŸ“¦ Checkout project repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0


      - name: ğŸ“¦ Setup Node + PNPM + install deps
        uses: ./.github/actions/setup-node-pnpm-install


      - name: Run prebuild
        run: pnpm run prebuild


      - name: ğŸš‘ Run Doctor Checks
        run: |
          chmod +x .github/scripts/expo-doctor.sh
          rm -rf ios android
          .github/scripts/expo-doctor.sh


      - name: Add doctor report as comment on PR
        if: github.event_name == 'pull_request' && always()
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          header: expo-doctor
          path: .expo/expo-doctor.md
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

### âš™ï¸ Compress Images

[Section titled â€œâš™ï¸ Compress Imagesâ€](#ï¸-compress-images)

.github/workflows/compress-images.yml

```yml
# ğŸ”— Links:
# Source file: https://github.com/leanhtuan1994/react-native-template-atlas/blob/master/.github/workflows/compress-images.yml


# âœï¸ Description:
# This workflow is used to compress images in the repo.
# This workflow will trigger on a push to the "master" or "main" branch and only run when a new image is added or updated.
# If it's the case, it will compress those images and create a pull request with the compressed images.


# ğŸš¨ GITHUB SECRETS REQUIRED: None


name: Compress images
on:
  push:
    branches:
      - master
      - main
    paths:
      - '**.jpg'
      - '**.jpeg'
      - '**.png'
      - '**.webp'
  workflow_dispatch:


jobs:
  build:
    name: calibreapp/image-actions
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Branch
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Compress Images
        id: calibre
        uses: calibreapp/image-actions@main
        with:
          githubToken: ${{ secrets.GITHUB_TOKEN }}
          compressOnly: true
          ignorePaths: 'node_modules/**,ios/**,android/**'


      - name: Create Pull Request
        if: steps.calibre.outputs.markdown != ''
        uses: peter-evans/create-pull-request@v3
        with:
          title: Auto Compress Images
          branch-suffix: timestamp
          commit-message: Compress Images
          body: ${{ steps.calibre.outputs.markdown }}
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

### âš™ï¸ Running Tests + Coverage Reports

[Section titled â€œâš™ï¸ Running Tests + Coverage Reportsâ€](#ï¸-running-tests--coverage-reports)

.github/workflows/test.yml

```yml
# ğŸ”— Links:
# Source file: https://github.com/leanhtuan1994/react-native-template-atlas/blob/master/.github/workflows/test.yml


# âœï¸ Description:
# This action is used to run unit tests
# Runs on pull requests and pushes to  the main/master branches
# Based on the event type:
#   - If it's a pull request, it will run the tests and post a comment with coverage details.
#   - If it's a push to main/master, it will run the tests and add the check to the commit.


# ğŸš¨ GITHUB SECRETS REQUIRED: NONE


name: Tests (jest)


on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]


jobs:
  test:
    name: Tests (jest)
    runs-on: ubuntu-latest


    steps:
      - name: ğŸ“¦ Checkout project repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0


      - name: ğŸ“¦ Setup Node + PNPM + install deps
        uses: ./.github/actions/setup-node-pnpm-install


      - name: ğŸƒâ€â™‚ï¸ Run Tests
        run: pnpm run test:ci


      - name: Jest Coverage Comment
        uses: MishaKav/jest-coverage-comment@main
        if: (success() || failure()) && github.event_name == 'pull_request'
        with:
          coverage-summary-path: ./coverage/coverage-summary.json
          summary-title: 'ğŸ’¯ Test Coverage'
          badge-title: Coverage
          create-new-comment: false
          junitxml-title: ğŸ˜ Tests Results
          junitxml-path: ./coverage/jest-junit.xml
          coverage-title: ğŸ‘€ Tests Details
          coverage-path: ./coverage/coverage.txt
          report-only-changed-files: true
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

### âš™ï¸ New App Version

[Section titled â€œâš™ï¸ New App Versionâ€](#ï¸-new-app-version)

.github/workflows/new-app-version.yml

```yml
# ğŸ”— Links:
# Source file: https://github.com/leanhtuan1994/react-native-template-atlas/blob/master/.github/workflows/lint-ts.yml
# Starter releasing process: https://starter.obytes.com/ci-cd/app-releasing-process/


# âœï¸ Description:
# This workflow is used to create a new version of the app and push a new tag to the repo.
# As this workflow will push code to the repo, we set up GitHub Bot as a Git user.
# This Workflow need to be triggered manually from the Actions tab in the repo.
#         1. Choose your release type (patch, minor, major)
#         2. The workflow will run the np-release script which runs the following steps:
#             - Bump the version in package.json based on the release type using np
#             - Run the prebuild of the app to align the package.json version with the native code
#             - Create a new tag with the new version
#             - Push the new tag to the repo
#


# ğŸš¨ GITHUB SECRETS REQUIRED:
#         - GH_TOKEN: A GitHub token with write repo access.
#           You can generate one from here: https://docs.github.com/en/enterprise-server@3.6/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens
#           make sure to add it to the repo secrets with the name GH_TOKEN


name: New App Version


on:
  workflow_dispatch:
    inputs:
      release-type:
        type: choice
        description: 'Release type (one of): patch, minor, major'
        required: true
        default: 'patch'
        options:
          - patch
          - minor
          - major


jobs:
  release:
    name: Create New Version and push new tag
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: ğŸ” GH_TOKEN
        if: env.GH_TOKEN == ''
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: echo "GH_TOKEN=${GITHUB_TOKEN}" >> $GITHUB_ENV
      - name: ğŸ“¦ Checkout project repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GH_TOKEN }}


      - name: ğŸ“ Git User Setup
        run: |
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"


      - name: ğŸ“¦ Setup Node + PNPM + install deps
        uses: ./.github/actions/setup-node-pnpm-install


      - name: ğŸƒâ€â™‚ï¸ Run App release
        run: |
          pnpm app-release ${{ github.event.inputs.release-type }}
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

### âš™ï¸ New Github Release

[Section titled â€œâš™ï¸ New Github Releaseâ€](#ï¸-new-github-release)

.github/workflows/new-github-release.yml

```yml
# ğŸ”— Links:
# Source file: https://github.com/leanhtuan1994/react-native-template-atlas/blob/master/.github/workflows/new-github-release.yml
# Starter releasing process: https://starter.obytes.com/ci-cd/app-releasing-process/


# âœï¸ Description:
# This workflow will be triggered automatically after the new app version workflow has been executed successfully.
# It will create a new GitHub release with the new app version and the release notes.


# ğŸš¨ GITHUB SECRETS REQUIRED: None


name: New GitHub Release


on:
  push:
    tags:
      - '*'


jobs:
  release:
    name: New GitHub Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: ğŸ“¦ Checkout project repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0


      - name: ğŸƒâ€â™‚ï¸Create A Draft Github Release
        uses: ncipollo/release-action@v1
        with:
          generateReleaseNotes: true
          draft: false
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

### âš™ï¸ EAS Build QA

[Section titled â€œâš™ï¸ EAS Build QAâ€](#ï¸-eas-build-qa)

.github/workflows/eas-build-qa.yml

```yml
# ğŸ”— Links:
# Source file: https://github.com/leanhtuan1994/react-native-template-atlas/blob/master/.github/workflows/eas-build-qa.yml
# Starter releasing process: https://starter.obytes.com/ci-cd/app-releasing-process/


# âœï¸ Description:
# This workflow is used to trigger a build on EAS for the QA environment.
# It will run on every GitHub release published on the repo or can be triggered manually from the actions tab.
# This workflow will use ./actions/eas-build action to trigger the build on EAS with staging env.


# ğŸš¨ GITHUB SECRETS REQUIRED:
#         - EXPO_TOKEN: Expo token to authenticate with EAS
#         - You can get it from https://expo.dev/settings/access-tokens


name: EAS QA Build (Android & IOS) (EAS)


on:
  workflow_dispatch:
  release:
    types: [published]


jobs:
  Build:
    name: EAS QA Build (Android & IOS) (EAS)
    runs-on: ubuntu-latest
    steps:
      - name: Check for EXPO_TOKEN
        run: |
          if [ -z "${{ secrets.EXPO_TOKEN }}" ]; then
            echo "You must provide an EXPO_TOKEN secret linked to this project's Expo account in this repo's secrets. Learn more: https://docs.expo.dev/eas-update/github-actions"
            exit 1
          fi
      - name: ğŸ“¦ Checkout project repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0


      - name: ğŸ“¦ Setup Node + PNPM + install deps
        uses: ./.github/actions/setup-node-pnpm-install


      - name: â±ï¸ EAS Build
        uses: ./.github/actions/eas-build
        with:
          APP_ENV: staging
          EXPO_TOKEN: ${{ secrets.EXPO_TOKEN }}
          VERSION: ${{ github.event.release.tag_name }}
          IOS: false # TODO: set as true when IOS account is ready
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

### âš™ï¸ EAS Build Prod

[Section titled â€œâš™ï¸ EAS Build Prodâ€](#ï¸-eas-build-prod)

.github/workflows/eas-build-prod.yml

```yml
# ğŸ”— Links:
# Source file: https://github.com/leanhtuan1994/react-native-template-atlas/blob/master/.github/workflows/eas-build-prod.yml
# Starter releasing process: https://starter.obytes.com/ci-cd/app-releasing-process/


# âœï¸ Description:
# This workflow is used to trigger a build on EAS for Prod environment.
# Can be triggered manually from the actions tab.
# This workflow will use ./actions/eas-build action to trigger the build on EAS with production env.


# ğŸš¨ GITHUB SECRETS REQUIRED:
#         - EXPO_TOKEN: Expo token to authenticate with EAS
#         - You can get it from https://expo.dev/settings/access-tokens


name: EAS Production Build (Android & IOS) (EAS)


on:
  workflow_dispatch:


jobs:
  Build:
    name: EAS Production Build (Android & IOS) (EAS)
    runs-on: ubuntu-latest
    steps:
      - name: Check for EXPO_TOKEN
        run: |
          if [ -z "${{ secrets.EXPO_TOKEN }}" ]; then
            echo "You must provide an EXPO_TOKEN secret linked to this project's Expo account in this repo's secrets. Learn more: https://docs.expo.dev/eas-update/github-actions"
            exit 1
          fi


      - name: ğŸ“¦ Checkout project repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0


      - name: ğŸ“¦ Setup Node + PNPM + install deps
        uses: ./.github/actions/setup-node-pnpm-install


      - name: â±ï¸ EAS Build
        uses: ./.github/actions/eas-build
        with:
          APP_ENV: production
          EXPO_TOKEN: ${{ secrets.EXPO_TOKEN }}
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

### âš™ï¸ E2E Test for Android

[Section titled â€œâš™ï¸ E2E Test for Androidâ€](#ï¸-e2e-test-for-android)

.github/workflows/e2e-android.yml

```yml
# ğŸ”— Links:
# Source file: https://github.com/leanhtuan1994/react-native-template-atlas/blob/master/.github/workflows/e2e-android.yml
# End-to-end testing: https://starter.obytes.com/testing/end-to-end-testing/


# âœï¸ Description:
# This workflow is used to run end-to-end tests on Android using Maestro.
# As a first step, it will generate a test APK using the Gradle build and then upload it as an artifact.
# A new job will be started to run the tests using the test APK generated in the previous job.
# To test the app, we set up an Android emulator using the `reactivecircus/android-emulator-runner` action. This runner requires macOS as the operating system for the runner.
# This workflow will be triggered on pull requests (PRs) with the label "android-test-github" or can be manually triggered from the Actions tab.
#


# ğŸš¨ GITHUB SECRETS REQUIRED: None


name: E2E Tests Android (Maestro + Github Action)


on:
  workflow_dispatch:
  pull_request:
    branches: [main, master]


jobs:
  generate-test-apk:
    if: github.event_name != 'pull_request' || ( github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'android-test-github'))
    name: Generate Test APK (Gradle)
    runs-on: ubuntu-latest


    steps:
      - name: ğŸ“¦ Checkout project repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0


      - name: ğŸ“¦ Setup Node + PNPM + install deps
        uses: ./.github/actions/setup-node-pnpm-install


      - name: ğŸ“¦ Set Up JDK + Generate Test APK
        uses: ./.github/actions/setup-jdk-generate-apk
        with:
          APP_ENV: staging


      - name: Upload Test APK
        uses: actions/upload-artifact@v3
        with:
          name: test-apk
          path: ./android/app/build/outputs/apk/release/app-release.apk


  test-android:
    name: Run Android E2E Tests (Maestro + Github Action)
    needs: generate-test-apk
    runs-on: macOS-latest


    steps:
      - name: ğŸ“¦ Checkout project repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0


      - name: ğŸ“¦ Install Maestro
        run: npm run install-maestro ## We use npm because we don't need to install deps again


      - name: Download Test APK
        uses: actions/download-artifact@v3
        with:
          name: test-apk
          path: ${{ github.workspace }}


      - name: Gradle cache
        uses: gradle/gradle-build-action@v2


      - name: AVD cache
        uses: actions/cache@v3
        id: avd-cache
        with:
          path: |
            ~/.android/avd/*
            ~/.android/adb*
          key: avd-cache


      - name: create AVD and generate snapshot for caching
        if: steps.avd-cache.outputs.cache-hit != 'true'
        uses: reactivecircus/android-emulator-runner@v2
        with:
          api-level: 29
          force-avd-creation: false
          emulator-options: -no-window -gpu swiftshader_indirect -noaudio -no-boot-anim -camera-back none
          disable-animations: false
          cores: 2
          ram-size: 4096M
          profile: Nexus 6
          script: echo "Generated AVD snapshot for caching."


      - name: Run tests with Maestro
        uses: reactivecircus/android-emulator-runner@v2
        with:
          api-level: 29
          force-avd-creation: false
          emulator-options: -no-snapshot-save -no-window -gpu swiftshader_indirect -noaudio -no-boot-anim -camera-back none
          disable-animations: false
          cores: 2
          ram-size: 4096M
          profile: Nexus 6
          script: |
            adb install "${{ github.workspace }}/app-release.apk"
            $HOME/.maestro/bin/maestro test .maestro/ --env=APP_ID=com.atlas.staging  --format junit


      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: e2e-test-logs
          path: ~/.maestro/tests/**/*


      - name: Store tests result
        uses: actions/upload-artifact@v3
        with:
          name: e2e_android_report
          path: |
            report.xml
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

### âš™ï¸ E2E Test for Android using Maestro Cloud

[Section titled â€œâš™ï¸ E2E Test for Android using Maestro Cloudâ€](#ï¸-e2e-test-for-android-using-maestro-cloud)

.github/workflows/e2e-android-maestro.yml

```yml
# ğŸ”— Links:
# Source file: https://github.com/leanhtuan1994/react-native-template-atlas/blob/master/.github/workflows/e2e-android.yml
# End-to-end testing: https://starter.obytes.com/testing/end-to-end-testing/


# âœï¸ Description:
# This workflow is used to run end-to-end tests on Android using Maestro Cloud.
# As a first step, it will generate a test APK using the Gradle build and  then trigger  Maestro Cloud to run the tests on the generated APK.
# This workflow will be triggered on pull requests (PRs) with the label "android-test-maestro-cloud" or can be manually triggered from the Actions tab.


# ğŸš¨ GITHUB SECRETS REQUIRED:
# MAESTRO_CLOUD_API_KEY: API key for Maestro Cloud. You can get it from https://cloud.mobile.dev/ci-integration/github-actions#add-your-api-key-secret


name: E2E Tests Android (Maestro Cloud)


on:
  workflow_dispatch:
  pull_request:
    branches: [main, master]


jobs:
  generate-and-test-apk:
    if: github.event_name != 'pull_request' || ( github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'android-test-maestro-cloud'))
    name: Generate and Test Test APK (Maestro Cloud)
    runs-on: ubuntu-latest


    steps:
      - name: ğŸ“¦ Checkout project repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0


      - name: ğŸ“¦ Setup Node + PNPM + install deps
        uses: ./.github/actions/setup-node-pnpm-install


      - name: ğŸ“¦ Set Up JDK + Generate Test APK
        uses: ./.github/actions/setup-jdk-generate-apk
        with:
          APP_ENV: staging


      - name: Upload Test APK
        uses: actions/upload-artifact@v3
        with:
          name: test-apk
          path: ./android/app/build/outputs/apk/release/app-release.apk


      - name: ğŸ“± Run E2E Tests with Maestro Cloud
        uses: mobile-dev-inc/action-maestro-cloud@v1.4.1
        with:
          api-key: ${{ secrets.MAESTRO_CLOUD_API_KEY }}
          app-file: ./android/app/build/outputs/apk/release/app-release.apk
          env: |
            APP_ID=com.atlas.staging
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

### âš™ï¸ E2E Test for Android using EAS Build

[Section titled â€œâš™ï¸ E2E Test for Android using EAS Buildâ€](#ï¸-e2e-test-for-android-using-eas-build)

.github/workflows/e2e-android-eas-build.yml

```yml
# ğŸ”— Links:
# Source file: https://github.com/leanhtuan1994/react-native-template-atlas/blob/master/.github/workflows/e2e-android-eas-build.yml
# End-to-end testing: https://starter.obytes.com/testing/end-to-end-testing/


# âœï¸ Description:
# This workflow is used to run end-to-end tests for EAS build on Android.
# It uses Maestro Cloud to run tests on Android emulator.
# It downloads the APK from EAS build and triggers the tests on Maestro Cloud with the downloaded APK.


# ğŸš¨ GITHUB SECRETS REQUIRED:
# MAESTRO_CLOUD_API_KEY: API key for Maestro Cloud. You can get it from https://cloud.mobile.dev/ci-integration/github-actions#add-your-api-key-secret


name: E2E Tests EAS Build Android (Maestro + Github Action)


on:
  workflow_dispatch:
    inputs:
      apk-url:
        type: string
        description: 'EAS APK URL'
        required: true
        default: ''


jobs:
  download-eas-apk:
    if: github.event_name != 'pull_request'  && github.event.inputs.apk-url != ''
    name: Download Test APK From EAS Url (wget)
    runs-on: ubuntu-latest


    steps:
      - name: ğŸ“¦ Download EAS APK
        run: wget ${{ github.event.inputs.apk-url }} -O ./app-release.apk


      - name: Upload Test APK
        uses: actions/upload-artifact@v3
        with:
          name: test-apk
          path: ./app-release.apk


  test-android:
    name: E2E Tests EAS Build Android (Maestro + Github Action)
    needs: download-eas-apk
    runs-on: macOS-latest


    steps:
      - name: ğŸ“¦ Checkout project repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0


      - name: ğŸ“¦ Install Maestro
        run: npm run install-maestro ## We use npm because we don't need to install deps again


      - name: Download Test APK
        uses: actions/download-artifact@v3
        with:
          name: test-apk
          path: ${{ github.workspace }}


      - name: Gradle cache
        uses: gradle/gradle-build-action@v2


      - name: AVD cache
        uses: actions/cache@v3
        id: avd-cache
        with:
          path: |
            ~/.android/avd/*
            ~/.android/adb*
          key: avd-cache


      - name: create AVD and generate snapshot for caching
        if: steps.avd-cache.outputs.cache-hit != 'true'
        uses: reactivecircus/android-emulator-runner@v2
        with:
          api-level: 29
          force-avd-creation: false
          emulator-options: -no-window -gpu swiftshader_indirect -noaudio -no-boot-anim -camera-back none
          disable-animations: false
          cores: 2
          ram-size: 4096M
          profile: Nexus 6
          script: echo "Generated AVD snapshot for caching."


      - name: Run tests with Maestro
        uses: reactivecircus/android-emulator-runner@v2
        with:
          api-level: 29
          force-avd-creation: false
          emulator-options: -no-snapshot-save -no-window -gpu swiftshader_indirect -noaudio -no-boot-anim -camera-back none
          disable-animations: false
          cores: 2
          ram-size: 4096M
          profile: Nexus 6
          script: |
            adb install "${{ github.workspace }}/app-release.apk"
            $HOME/.maestro/bin/maestro test .maestro/ --env=APP_ID=com.atlas.staging  --format junit


      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: e2e-test-logs
          path: ~/.maestro/tests/**/*


      - name: Store tests result
        uses: actions/upload-artifact@v3
        with:
          name: e2e_android_report
          path: |
            report.xml
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

# Frequently asked questions

> Frequently asked questions about the React Native / Expo Starter.

This page is a collection of frequently asked questions about the React Native / Expo Starter.

### Is this starter for me?

[Section titled â€œIs this starter for me?â€](#is-this-starter-for-me)

Yes ğŸ˜€

This starter kit is designed to benefit a wide range of React Native developers, from beginners to experienced professionals. Hereâ€™s why it might be a good fit for you:

1. **For beginners:** It provides a solid foundation with best practices and common solutions, helping you learn industry-standard approaches to React Native development.

2. **For experienced developers:** It offers a well-structured, production-ready setup that can save you time and effort in project initialization and configuration.

3. **For teams:** It ensures consistency across projects and team members, making it easier to onboard new developers and maintain code quality.

4. **For explorers:** Even if you prefer not to use starter kits, this project can serve as a valuable reference. You can explore the codebase, documentation, and architectural decisions to gain insights and potentially adopt specific solutions for your projects.

5. **For learners:** The starter kit incorporates up-to-date libraries and patterns, allowing you to familiarize yourself with current best practices in the React Native ecosystem.

6. **For AI-assisted development:** This starter kit works well with AI coding tools. It provides a solid structure and best practices that can guide AI-generated code. This helps ensure that AI assistance leads to high-quality, maintainable code that fits well within your project.

Remember, you donâ€™t have to use the entire starter kit as-is. Feel free to cherry-pick ideas, configurations, or code snippets that align with your project needs. Whether youâ€™re building a new app from scratch or looking to improve your existing development process, this starter kit can provide valuable insights and practical solutions.

### Why Expo and not React Native CLI?

[Section titled â€œWhy Expo and not React Native CLI?â€](#why-expo-and-not-react-native-cli)

We have been using Expo as our main framework since the introduction of [Continuous Native Generation (CNG)](https://docs.expo.dev/workflow/continuous-native-generation/) concept and we are happy with the experience.

I think this question is not valid anymore, especially after the last React conference when the core React native team recommended using Expo for new projects.

> â€œAs of today, the only recommended community framework for React Native is Expo. Folks at Expo have been investing in the React Native ecosystem since the early days of React Native and as of today, we believe the developer experience offered by Expo is best in class.â€ React native core team

Still hesitating? Check out this [article](https://reactnative.dev/blog/2024/06/25/use-a-framework-to-build-react-native-apps) or this [video](https://www.youtube.com/watch?v=lifGTznLBcw), maybe this one [video](https://www.youtube.com/watch?v=ek_IdGC0G80) too.

### Who is behind the starter kit?

[Section titled â€œWho is behind the starter kit?â€](#who-is-behind-the-starter-kit)

This starter kit has been maintained by the [Obytes mobile tribe team](https://www.obytes.com/team) since 2021. We actively use it for our internal projects and are excited to share it with the amazing React Native / Expo community. The project is open-source, released under the MIT license, ensuring flexibility for users. Our commitment to this starter kit is ongoing; we will continue to maintain and improve it as long as it remains a core part of our internal development process. We welcome contributions and feedback from the community to help make this starter kit even better.

### Can you include X feature or library?

[Section titled â€œCan you include X feature or library?â€](#can-you-include-x-feature-or-library)

We aim to keep the starter as simple as possible. Based on our experience, we believe the current setup provides a solid foundation for most projects.

The starter is opinionated, reflecting our best practices. If you disagree with some of our choices, thatâ€™s perfectly fine. The starter is designed to be easily customizable to suit your specific needs.

We often receive requests to provide multiple choices for libraries and tools through a CLI. While this may seem appealing, it would significantly increase complexity and maintenance overhead, which we are trying to avoid.

# Create a new App

> Let's create a new React native project with obytes starter.

Letâ€™s create a new React Native project with Obytes starter.

## Requirements

[Section titled â€œRequirementsâ€](#requirements)

First make sure you have the following tools installed on your machine:

* [React Native dev environment](https://reactnative.dev/docs/environment-setup)
* [Node.js LTS release](https://nodejs.org/en/)
* [Git](https://git-scm.com/)
* [Watchman](https://facebook.github.io/watchman/docs/install#buildinstall), required only for macOS or Linux users
* [Pnpm](https://pnpm.io/installation)
* [Cursor](https://www.cursor.com/) is recommended but you can use [VS Code Editor](https://code.visualstudio.com/download).

## Initializing a new project

[Section titled â€œInitializing a new projectâ€](#initializing-a-new-project)

First make sure you have `pnpm` installed on your machine, if not you can install it using the following command:

```bash
npm install -g pnpm
```

Start your project using `create-obytes-app` command:

```bash
npx create-obytes-app@latest MyApp
```

The command will create an expo app named `MyApp` and install all the dependencies added by the starter.

Note

Because weâ€™re using the Expo custom dev client to support native dependencies with the starter, The Expo Go app is not an option to consider here. Instead, you need to create the app and install it on your simulator or device to start using it.

Note

Adhere to Androidâ€™s specific naming conventions as described in [the Android documentation](https://developer.android.com/build/configure-app-module). The name must satisfy the following rules:

* It must have at least two segments (one or more dots).
* Each segment must start with a letter.
* All characters must be alphanumeric or an underscore \[a-zA-Z0-9\_].

## Open Project on Cursor or VS Code

[Section titled â€œOpen Project on Cursor or VS Codeâ€](#open-project-on-cursor-or-vs-code)

Cursor is the recommended editor for this starter, The starter comes with a list of recommended extensions, settings and project snippets that we think will improve your coding experience.

Open the project on Cursor using the following command:

```bash
cursor .
```

When you open the project on Cursor you will see a popup asking you to install the recommended extensions, The easy way is to install all recommended extensions by clicking on `Install All` button.

To ensure that your code is properly validated and formatted, we highly recommend installing all of the recommended extensions. However, if youâ€™re hesitant to install them all, we suggest at least installing the following extensions, as they are essential to our code validation and formatting on file save:

* [ESLint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint)
* [Prettier](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode)
* [Tailwindcss IntelliSense](https://marketplace.visualstudio.com/items?itemName=bradlc.vscode-tailwindcss)
* [Pretty TypeScript Errors](https://marketplace.visualstudio.com/items?itemName=yoavbls.pretty-ts-errors)

Here is the complete list of recommended extensions:

* [ESLint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint)
* [Prettier](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode)
* [tailwindcss IntelliSense](https://marketplace.visualstudio.com/items?itemName=bradlc.vscode-tailwindcss)
* [Auto Rename Tag](https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag)
* [Auto close tag](https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-close-tag)
* [Code spell checker](https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker)
* [GitLens](https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens)
* [Import Cost](https://marketplace.visualstudio.com/items?itemName=wix.vscode-import-cost)
* [Cobalt 2 theme](https://marketplace.visualstudio.com/items?itemName=ahmadawais.theme-cobalt2)
* [Turbo console log](https://marketplace.visualstudio.com/items?itemName=ChakrounAnas.turbo-console-log)
* [i18n Ally](https://marketplace.visualstudio.com/items?itemName=lokallise.i18n-ally)
* [Pretty TypeScript Errors](https://marketplace.visualstudio.com/items?itemName=yoavbls.pretty-ts-errors)

## Running the app

[Section titled â€œRunning the appâ€](#running-the-app)

If the installation was successful, the created app should be ready to use, and because we are using the expo custom dev client, you may launch the app on your simulator or device by running the following command:

```bash
# Run the app on iOS simulator
pnpm ios


# Run the app on Android simulator
pnpm android
```

# Customize your App

> Customize your app by updating Expo configuration and app icon and splash screen.

The starter is a simple expo app. You just need to edit `app.config.ts` file to update expo attributes and configuration.

Here is the complete config file :

app.config.ts

```ts
import type { ConfigContext, ExpoConfig } from '@expo/config';
import type { AppIconBadgeConfig } from 'app-icon-badge/types';


import { ClientEnv, Env } from './env';


const appIconBadgeConfig: AppIconBadgeConfig = {
  enabled: Env.APP_ENV !== 'production',
  badges: [
    {
      text: Env.APP_ENV,
      type: 'banner',
      color: 'white',
    },
    {
      text: Env.VERSION.toString(),
      type: 'ribbon',
      color: 'white',
    },
  ],
};


export default ({ config }: ConfigContext): ExpoConfig => ({
  ...config,
  name: Env.NAME,
  description: `${Env.NAME} Mobile App`,
  owner: Env.EXPO_ACCOUNT_OWNER,
  scheme: Env.SCHEME,
  slug: 'atlasapp',
  version: Env.VERSION.toString(),
  orientation: 'portrait',
  icon: './assets/icon.png',
  userInterfaceStyle: 'automatic',
  newArchEnabled: true,
  updates: {
    fallbackToCacheTimeout: 0,
  },
  assetBundlePatterns: ['**/*'],
  ios: {
    supportsTablet: true,
    bundleIdentifier: Env.BUNDLE_ID,
    infoPlist: {
      ITSAppUsesNonExemptEncryption: false,
    },
  },
  experiments: {
    typedRoutes: true,
    reactCompiler: true,
  },
  android: {
    adaptiveIcon: {
      foregroundImage: './assets/adaptive-icon.png',
      backgroundColor: '#2E3C4B',
    },
    package: Env.PACKAGE,
    edgeToEdgeEnabled: true,
    predictiveBackGestureEnabled: false,
  },
  web: {
    favicon: './assets/favicon.png',
    bundler: 'metro',
  },
  plugins: [
    [
      'expo-splash-screen',
      {
        backgroundColor: '#2E3C4B',
        image: './assets/splash-icon.png',
        imageWidth: 150,
      },
    ],
    ['expo-font'],
    'expo-localization',
    'expo-router',
    ['app-icon-badge', appIconBadgeConfig],
    ['react-native-edge-to-edge'],
  ],
  extra: {
    ...ClientEnv,
    eas: {
      projectId: Env.EAS_PROJECT_ID,
    },
  },
});
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

You can read more about expo configuration [here](https://docs.expo.io/workflow/configuration/). If you have any configurations that depend on environment variables, such as API URLs or keys, you can create it in `config` file following [the environment variables guide](/getting-started/environment-vars-config) and import your config to `app.config.ts` file.

Note

We included TODO comments in the project to guide you to the areas requiring updates.

## Splash screen and app icon

[Section titled â€œSplash screen and app iconâ€](#splash-screen-and-app-icon)

As we are using expo to create the starter, updating the app icon and splash screen is straightforward. You only need to update the app icon and splash screen images inside the `assets` folder and run `expo prebuild` to update the app icon and splash screen.

As we are supporting multiple variants for development, staging and production environments you need 3 different icons but the right solution is to use the same icon with badges for each environment.

For more details about the app icon and splash screen, please refer to the expo documentation.

ğŸ‘‰ [Create a splash screen](https://docs.expo.dev/guides/splash-screens/)

# Environment Variables and Configuration

> Environment variables and configuration with validation and type-checking.

Managing environment variables in your project is an essential task, but it can also be challenging. Thatâ€™s why we have included a complete setup for environment variables in this project. This setup comes with validation and type-checking using the `zod` library.

All the code related to environment variables is located in the `env.js` and `src/lib/env.js` files. The `env.js` read the `APP_ENV` variable and loads the correct `.env` file, then defines the `zod` schema for the environment variables for client and build-time, parses the `_env` object, and returns the parsed object, or throws errors in case of invalid or missing variables.

To increase security, we are splitting environment variables into two parts:

* **Client Variables**: Variables that are safe to be exposed to the client and used in your `src` folder. These variables are passed to the client side using the `extra` configuration in the `app.config.ts` file.
* **Build Time Variables**: Variables that we donâ€™t need on the client-side and are only used in the `app.config.ts`, for example `SENTRY_AUTH` to upload the source maps to Sentry.

By using this pre-configured setup for environment variables, you can focus on building your project without worrying about managing and validating your environment variables.

This setup is highly inspired by [T3 Stack](https://create.t3.gg/) ğŸ‘Œ

## Adding a new environment variable to the project.

[Section titled â€œAdding a new environment variable to the project.â€](#adding-a-new-environment-variable-to-the-project)

To add a new environment variable to the project, follow these steps:

1. Add the new environment variable to the correct `zod` schema inside the `env.js` file based on this simple rule : If the variable is used in the `src` folder, add it to the `client` schema, otherwise add it to the `buildTime` schema.

This will ensure that the new variable is validated correctly. and make sure we are only sending the correct vars to the client side Hereâ€™s an example:

env.js

```js
const client = z.object({
  // ...
  // add the new environment variable here/ accessible on the client side and build time(app.config.ts)
  NEW_ENV_VAR: z.string(),
});


const buildTime = z.object({
  // ...
  // add the new environment variable here / accessible only on build time(app.config.ts)
  NEW_SECRET_ENV: z.string(),
});
```

2. Add the new environment variable to the correct env object inside the `env.js`, `_clientEnv` for client variables and `_buildTimeEnv` for build time variables. Hereâ€™s an example:

env.js

```js
const _clientEnv = {
  // ...
  // add the new environment variable here
  NEW_ENV_VAR: process.env.NEW_ENV_VAR,
};


const _buildTimeEnv = {
  // ...
  // add the new environment variable here
  NEW_SECRET_ENV: process.env.NEW_SECRET_ENV,
};
```

3. Add the new environment variable to your `.env` files. Make sure to include it in all relevant files (`development`, `staging`, and `production`). Hereâ€™s an example:

.env.{APP\_ENV}

```bash
# ...
# add the new environment variable here
NEW_ENV_VAR=my-new-var
```

Note

if you are not pushing env files to your repo(recomended), please make sure to check the [App releasing process](/ci-cd/app-releasing-process/#github-action-and-env-variables) to see how to create the env file on the fly before the prebuild script in the github actions.

4. Make sure to run `pnpm prebuild` to load the new values.

```bash
pnpm prebuild
```

5. The new environment variable is now ready to use in your project. You can access it in your code using the `Env` object, like this:

client.ts

```ts
import { Env } from '@env';
import axios from 'axios';
export const client = axios.create({
  baseURL: Env.API_URL,
});
```

Important

Using `import { Env } from '@env';` will import the env from the `src/lib/env.js` file, which export client only env vars.

6. Use `APP_ENV` to load the correct `.env` file :

```bash
APP_ENV=production pnpm start -cc
```

As mentioned earlier, `zod` is used to validate environment variables at runtime and build time. If there are any missing or invalid variables, youâ€™ll see an error message with information on what needs to be fixed. Hereâ€™s an example error message:

```bash
âŒ Invalid environment variables: { TEST: [ 'Required' ] }
âŒ Missing variables in .env.development file, Make sure all required variables are defined in the .env.development file.
ğŸ’¡ Tip: If you recently updated the .env.development file and the error still persists, try restarting the server with the -c flag to clear the cache.
```

Important

As `dotenv` handles variables as strings, you need to convert them to the correct type while reading them from the `process.env` object. check the example below for more details on how to use numbers and boolean values.

## How it works

[Section titled â€œHow it worksâ€](#how-it-works)

#### âœ… Validate and parse environment variables

[Section titled â€œâœ… Validate and parse environment variablesâ€](#-validate-and-parse-environment-variables)

If you take a look at the `env.js` file, you will notice that the file is split into three main parts as shown below:

env.js

```js
/* eslint-env node */
/*
 * Env file to load and validate env variables
 * Be cautious; this file should not be imported into your source folder.
 * We split the env variables into two parts:
 * 1. Client variables: These variables are used in the client-side code (src folder).
 * 2. Build-time variables: These variables are used in the build process (app.config.ts file).
 * Import this file into the `app.config.ts` file to use environment variables during the build process. The client variables can then be passed to the client-side using the extra field in the `app.config.ts` file.
 * To access the client environment variables in your `src` folder, you can import them from `@env`. For example: `import Env from '@env'`.
 */
/**
 * 1st part: Import packages and Load your env variables
 * we use dotenv to load the correct variables from the .env file based on the APP_ENV variable (default is development)
 * APP_ENV is passed as an inline variable while executing the command, for example: APP_ENV=staging pnpm build:android
 */
const z = require('zod');


const packageJSON = require('./package.json');
const path = require('path');
const APP_ENV = process.env.APP_ENV ?? 'development';
// eslint-disable-next-line no-undef
const envPath = path.resolve(__dirname, `.env.${APP_ENV}`);


require('dotenv').config({
  path: envPath,
});


/**
 * 2nd part: Define some static variables for the app
 * Such as: bundle id, package name, app name.
 *
 * You can add them to the .env file but we think it's better to keep them here as as we use prefix to generate this values based on the APP_ENV
 * for example: if the APP_ENV is staging, the bundle id will be com.obytes.staging
 */


// TODO: Replace these values with your own


const BUNDLE_ID = 'com.atlas'; // ios bundle id
const PACKAGE = 'com.atlas'; // android package name
const NAME = 'AtlasApp'; // app name
const EXPO_ACCOUNT_OWNER = 'leanhtuan1994'; // expo account owner
const EAS_PROJECT_ID = 'c3e1075b-6fe7-4686-aa49-35b46a229044'; // eas project id
const SCHEME = 'atlasApp'; // app scheme


/**
 * We declare a function withEnvSuffix that will add a suffix to the variable name based on the APP_ENV
 * Add a suffix to variable env based on APP_ENV
 * @param {string} name
 * @returns  {string}
 */


const withEnvSuffix = (name) => {
  return APP_ENV === 'production' ? name : `${name}.${APP_ENV}`;
};


/**
 * 2nd part: Define your env variables schema
 * we use zod to define our env variables schema
 *
 * we split the env variables into two parts:
 *    1. client: These variables are used in the client-side code (`src` folder).
 *    2. buildTime: These variables are used in the build process (app.config.ts file). You can think of them as server-side variables.
 *
 * Main rules:
 *    1. If you need your variable on the client-side, you should add it to the client schema; otherwise, you should add it to the buildTime schema.
 *    2. Whenever you want to add a new variable, you should add it to the correct schema based on the previous rule, then you should add it to the corresponding object (_clientEnv or _buildTimeEnv).
 *
 * Note: `z.string()` means that the variable exists and can be an empty string, but not `undefined`.
 * If you want to make the variable required, you should use `z.string().min(1)` instead.
 * Read more about zod here: https://zod.dev/?id=strings
 *
 */


const client = z.object({
  APP_ENV: z.enum(['development', 'staging', 'production']),
  NAME: z.string(),
  SCHEME: z.string(),
  BUNDLE_ID: z.string(),
  PACKAGE: z.string(),
  VERSION: z.string(),


  // ADD YOUR CLIENT ENV VARS HERE
  API_URL: z.string(),
  VAR_NUMBER: z.number(),
  VAR_BOOL: z.boolean(),
});


const buildTime = z.object({
  EXPO_ACCOUNT_OWNER: z.string(),
  EAS_PROJECT_ID: z.string(),
  // ADD YOUR BUILD TIME ENV VARS HERE
  SECRET_KEY: z.string(),
});


/**
 * @type {Record<keyof z.infer<typeof client> , unknown>}
 */
const _clientEnv = {
  APP_ENV,
  NAME: NAME,
  SCHEME: SCHEME,
  BUNDLE_ID: withEnvSuffix(BUNDLE_ID),
  PACKAGE: withEnvSuffix(PACKAGE),
  VERSION: packageJSON.version,


  // ADD YOUR ENV VARS HERE TOO
  API_URL: process.env.API_URL,
  VAR_NUMBER: Number(process.env.VAR_NUMBER),
  VAR_BOOL: process.env.VAR_BOOL === 'true',
};


/**
 * @type {Record<keyof z.infer<typeof buildTime> , unknown>}
 */
const _buildTimeEnv = {
  EXPO_ACCOUNT_OWNER,
  EAS_PROJECT_ID,
  // ADD YOUR ENV VARS HERE TOO
  SECRET_KEY: process.env.SECRET_KEY,
};


/**
 * 3rd part: Merge and Validate your env variables
 * We use zod to validate our env variables based on the schema we defined above
 * If the validation fails we throw an error and log the error to the console with a detailed message about missed variables
 * If the validation passes we export the merged and parsed env variables to be used in the app.config.ts file as well as a ClientEnv object to be used in the client-side code
 **/
const _env = {
  ..._clientEnv,
  ..._buildTimeEnv,
};


const merged = buildTime.merge(client);
const parsed = merged.safeParse(_env);


if (parsed.success === false) {
  console.error(
    'âŒ Invalid environment variables:',
    parsed.error.flatten().fieldErrors,


    `\nâŒ Missing variables in .env.${APP_ENV} file, Make sure all required variables are defined in the .env.${APP_ENV} file.`,
    `\nğŸ’¡ Tip: If you recently updated the .env.${APP_ENV} file and the error still persists, try restarting the server with the -c flag to clear the cache.`
  );
  throw new Error(
    'Invalid environment variables, Check terminal for more details '
  );
}


const Env = parsed.data;
const ClientEnv = client.parse(_clientEnv);


module.exports = {
  Env,
  ClientEnv,
  withEnvSuffix,
};
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

**In the first part** We load the correct `.env` file based on the `APP_ENV` variable using `dotenv` package. If the `APP_ENV` variable is not defined, we default to `development`.

we define some static variables for the app such as the app name, bundle Id and package. While these variables can be added to the `.env` files, we recommend keeping them in the `env.js` file as they are not meant to change. To handle different app variants, you can add suffixes to these variables using the `withEnvSuffix` function.

**In the second part**, we define the `zod` schema for the environment variables.

We split the environment variables into two parts:

* **Client Variables**: Variables that are safe to be exposed to the client and used in the `src` folder.

* **Build Time Variables**: Variables that we donâ€™t need on the client-side and are only used in the `app.config.ts`, for example, `SENTRY_AUTH` to upload the source maps to Sentry.

These schemas are used to validate the environment variables. All the environment variables should be added to the correct schema.

We use the `z.infer` utility to infer the environment variablesâ€™ types from the schema and use it to define the `_clientEnv` and `_buildTimeEnv` objectsâ€™ type. This means that if you add a new environment variable to the schema, you will get a type error if you donâ€™t add it to the correct `_clientEnv` and `_buildTimeEnv` object as well, and vice versa.

**Finally**, in the third part, we merge variables to `_env`, pare it using the zod schema, and return the parsed object as well as the client environment variable, or throw errors in case of invalid or missing variables.

#### âœ… Use and send environment variables to the client

[Section titled â€œâœ… Use and send environment variables to the clientâ€](#-use-and-send-environment-variables-to-the-client)

Now itâ€™s as easy as importing `Env` , `ClientEnv` and `withEnvSuffix` from the `./env.js` file and use inside our `app.config.ts`, and finally sending client env vars to the client side using `extra` property.

app.config.ts

```ts
import type { ConfigContext, ExpoConfig } from '@expo/config';
import type { AppIconBadgeConfig } from 'app-icon-badge/types';


import { ClientEnv, Env } from './env';


const appIconBadgeConfig: AppIconBadgeConfig = {
  enabled: Env.APP_ENV !== 'production',
  badges: [
    {
      text: Env.APP_ENV,
      type: 'banner',
      color: 'white',
    },
    {
      text: Env.VERSION.toString(),
      type: 'ribbon',
      color: 'white',
    },
  ],
};


export default ({ config }: ConfigContext): ExpoConfig => ({
  ...config,
  name: Env.NAME,
  description: `${Env.NAME} Mobile App`,
  owner: Env.EXPO_ACCOUNT_OWNER,
  scheme: Env.SCHEME,
  slug: 'atlasapp',
  version: Env.VERSION.toString(),
  orientation: 'portrait',
  icon: './assets/icon.png',
  userInterfaceStyle: 'automatic',
  newArchEnabled: true,
  updates: {
    fallbackToCacheTimeout: 0,
  },
  assetBundlePatterns: ['**/*'],
  ios: {
    supportsTablet: true,
    bundleIdentifier: Env.BUNDLE_ID,
    infoPlist: {
      ITSAppUsesNonExemptEncryption: false,
    },
  },
  experiments: {
    typedRoutes: true,
    reactCompiler: true,
  },
  android: {
    adaptiveIcon: {
      foregroundImage: './assets/adaptive-icon.png',
      backgroundColor: '#2E3C4B',
    },
    package: Env.PACKAGE,
    edgeToEdgeEnabled: true,
    predictiveBackGestureEnabled: false,
  },
  web: {
    favicon: './assets/favicon.png',
    bundler: 'metro',
  },
  plugins: [
    [
      'expo-splash-screen',
      {
        backgroundColor: '#2E3C4B',
        image: './assets/splash-icon.png',
        imageWidth: 150,
      },
    ],
    ['expo-font'],
    'expo-localization',
    'expo-router',
    ['app-icon-badge', appIconBadgeConfig],
    ['react-native-edge-to-edge'],
  ],
  extra: {
    ...ClientEnv,
    eas: {
      projectId: Env.EAS_PROJECT_ID,
    },
  },
});
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

#### âœ… Type checking for client environment variables

[Section titled â€œâœ… Type checking for client environment variablesâ€](#-type-checking-for-client-environment-variables)

Here, we added a separate file to export all variables that have already been passed in the `extra` property to the client side. We added a little bit of magic to make it type-safe and easy to use.

src/lib/env.js

```js
/*
 * This file should not be modified; use `env.js` in the project root to add your client environment variables.
 * If you import `Env` from `@env`, this is the file that will be loaded.
 * You can only access the client environment variables here.
 * NOTE: We use js file so we can load the client env types
 */


import Constants from 'expo-constants';
/**
 *  @type {typeof import('../../env.js').ClientEnv}
 */
//@ts-ignore // Don't worry about TypeScript here; we know we're passing the correct environment variables to `extra` in `app.config.ts`.
export const Env = Constants.expoConfig?.extra ?? {};
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

Now the environment variables are ready to use in your project. You can access them in your code by importing `Env` from `@env` and using it like this:

client.ts

```ts
import { Env } from '@env';
import axios from 'axios';
export const client = axios.create({
  baseURL: Env.API_URL,
});
```

# Project Structure

> Project structure files and folders.

If you open the new project in VSCode you will see the following structure:

* api ## any thing related to api calls and data fetching

  * common/

    * â€¦

  * index.tsx

  * posts

  * types.ts

* app ## app routes and layouts

  * (app)/

    * â€¦

  * \_layout.tsx

  * feed/

    * â€¦

  * login.tsx

  * onboarding.tsx

* components ## any reusable components

  * ui ## core ui and theme configuration

    * button.tsx
    * checkbox.tsx
    * colors.js
    * focus-aware-status-bar.tsx
    * icons
    * image.tsx
    * index.tsx
    * input.tsx
    * list.tsx
    * modal.tsx
    * progress-bar.tsx
    * select.tsx
    * text.tsx
    * utils.tsx

  * buttons.tsx

  * card.tsx

  * colors.tsx

  * cover.tsx

  * inputs.tsx

  * login-form.test.tsx

  * login-form.tsx

  * settings/

    * â€¦

  * title.tsx

  * typography.tsx

* lib ## core files such as auth, localization, storage and more

  * auth
  * contexts
  * env.js
  * hooks
  * i18n
  * index.tsx
  * storage.tsx
  * test-utils.tsx
  * utils.ts

* translations ## translation resources files

  * ar.json
  * en.json

* types ## global types

  * index.ts

- `components/ui`: This folder contains all the UI components and the theme configuration. We provide minimal components with a basic `obytes` theme. You can add your own components and theme configuration here.

- `components`: This folder contains the components of the app. mainly components used inside the app folder.

- `lib`: This folder contains the core files, such as authentication, localization, storage, and more. It can be shared with other projects. Thatâ€™s why we are only including modules that have nothing to do with project logic. This approach helps us share code between projects and also update the starter with new features.

- `app`: This folder contains the routes of the app, along with its layout routes such as stack and tab navigation structures. We provide a basic navigation structure for the demo app that you can modify to fit your needs.

- `api`: This folder contains the API files. We provide a basic API client and provider and you just need to create query and mutation for your modules. Check `posts` folder for inspiration on how to create a query and mutation.

- `translations`: This folder contains the translation resources files. We recommend using translation files even if you are not supporting multiple languages as it will help you to support multiple languages in the future and also help you to find all the strings in one place.

- `types`: This folder contains the global types.

Note

The structure is very opinionated but we think itâ€™s the best way to structure a react native project. For sure you can change it as you like based on your needs.

## Importing files

[Section titled â€œImporting filesâ€](#importing-files)

We use absolute imports to import files using the Babel module resolver plugin and TypeScript path mapping. This approach helps us avoid long relative paths and makes the code cleaner and more readable.

Here is a simple example of how the Feed screen looks with absolute imports.

src/app/(app)/index.tsx

```tsx
import { FlashList } from '@shopify/flash-list';
import React from 'react';


import type { Post } from '@/api';
import { usePosts } from '@/api';
import { Card } from '@/components/card';
import { EmptyList, FocusAwareStatusBar, Text, View } from '@/components/ui';


export default function Feed() {
  const { data, isPending, isError } = usePosts();
  const renderItem = React.useCallback(
    ({ item }: { item: Post }) => <Card {...item} />,
    []
  );


  if (isError) {
    return (
      <View>
        <Text> Error Loading data </Text>
      </View>
    );
  }
  return (
    <View className="flex-1">
      <FocusAwareStatusBar />
      <FlashList
        data={data}
        renderItem={renderItem}
        keyExtractor={(_, index) => `item-${index}`}
        ListEmptyComponent={<EmptyList isLoading={isPending} />}
      />
    </View>
  );
}
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

This approach is very useful when you are working on a large project with a lot of files and folders and it can be done by updating the `babel.config.js` file and `tsconfig.json` file to the following:

âš™ï¸ Babel configuration

babel.config.js

```js
module.exports = function (api) {
  api.cache(true);
  return {
    presets: [['babel-preset-expo']],
    plugins: [
      [
        'module-resolver',
        {
          root: ['./'],
          alias: {
            '@': './src',
            '@env': './src/lib/env.js',
          },
          extensions: [
            '.ios.ts',
            '.android.ts',
            '.ts',
            '.ios.tsx',
            '.android.tsx',
            '.tsx',
            '.jsx',
            '.js',
            '.json',
          ],
        },
      ],
      'react-native-worklets/plugin',
    ],
  };
};
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

âš™ï¸ Typescript Config

tsconfig.json

```json
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"],
      "@env": ["./src/lib/env.js"]
    },
    "esModuleInterop": true,
    "checkJs": true
  },
  "exclude": [
    "node_modules",
    "babel.config.js",
    "metro.config.js",
    "docs",
    "cli",
    "android",
    "ios",
    "lint-staged.config.js"
  ],
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".expo/types/**/*.ts",
    "expo-env.d.ts",
    "uniwind-env.d.ts"
  ]
}
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

# Rules and Conventions

> Rules and conventions that we follow in the starter.

In order to enforce a consistent code style and avoid common issues in the codebase, we have a set of rules and conventions that we follow and enforce through the starter.

## Typescript

[Section titled â€œTypescriptâ€](#typescript)

This starter uses TypeScript to provide type safety and avoid common bugs in the codebase. The project configuration is based on Expo config with some updates to support absolute imports.

If you are not familiar with Typescript, you can check this article to learn more about it : [Typescript for React Developers](https://elazizi.com/posts/how-to-learn-typescript-for-react-developers/)

You can find more information about it [here](https://docs.expo.io/guides/typescript/).

## Naming

[Section titled â€œNamingâ€](#naming)

We follow kabab-case for naming files and folders as we think itâ€™s the most readable and consistent way to name files and folders in large projects and itâ€™s the most common way to name files and folders in the react native community.

Example of kabab-case naming: `my-component.tsx`

For naming variables, functions, classes, interfaces, and enums, we follow camelCase as itâ€™s the most common way to name variables in the React community. It is enforced by the linter, as you cannot create a function component without using camelCase.

## Linting

[Section titled â€œLintingâ€](#linting)

Using a linter is a must in any JavaScript project. For starters, we are using ESLint with the React Native community config and some custom rules to ensure that we are following the rules and conventions related to file naming, Tailwind CSS classes, TypeScript types, import order, internationalization files, and more.

Here is the complete ESLint configuration file:

eslint.config.mjs

```mjs
import path from 'node:path';
import { fileURLToPath } from 'node:url';


import { defineConfig, globalIgnores } from 'eslint/config';
import expoConfig from 'eslint-config-expo/flat.js';
import i18nJsonPlugin from 'eslint-plugin-i18n-json';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import reactCompiler from 'eslint-plugin-react-compiler';
import simpleImportSort from 'eslint-plugin-simple-import-sort';
import testingLibrary from 'eslint-plugin-testing-library';
// eslint-disable-next-line import/no-named-as-default, import/no-named-as-default-member, import/namespace
import eslintPluginUnicorn from 'eslint-plugin-unicorn';
import unusedImports from 'eslint-plugin-unused-imports';
import { configs, parser } from 'typescript-eslint';


const __dirname = path.dirname(fileURLToPath(import.meta.url));


export default defineConfig([
  globalIgnores([
    'dist/*',
    'node_modules',
    '__tests__/',
    'coverage',
    '.expo',
    '.expo-shared',
    'android',
    'ios',
    '.vscode',
    'docs/',
    'cli/',
    'expo-env.d.ts',
  ]),
  expoConfig,
  eslintPluginPrettierRecommended,
  reactCompiler.configs.recommended,
  {
    plugins: {
      'simple-import-sort': simpleImportSort,
      unicorn: eslintPluginUnicorn,
      'unused-imports': unusedImports,
    },
    rules: {
      'max-params': ['error', 3],
      'max-lines-per-function': ['error', 70],
      'react/display-name': 'off',
      'react/no-inline-styles': 'off',
      'react/destructuring-assignment': 'off',
      'react/require-default-props': 'off',
      'unicorn/filename-case': [
        'error',
        {
          case: 'kebabCase',
          ignore: ['/android', '/ios'],
        },
      ],
      'simple-import-sort/imports': 'error',
      'simple-import-sort/exports': 'error',
      'unused-imports/no-unused-imports': 'error',
      'unused-imports/no-unused-vars': [
        'error',
        {
          argsIgnorePattern: '^_',
          varsIgnorePattern: '^_',
          caughtErrorsIgnorePattern: '^_',
        },
      ],
      'import/prefer-default-export': 'off',
      'import/no-cycle': ['error', { maxDepth: 'âˆ' }],
      'prettier/prettier': ['error', { ignores: ['expo-env.d.ts'] }],
    },
  },
  {
    files: ['**/*.ts', '**/*.tsx'],
    languageOptions: {
      parser: parser,
      parserOptions: {
        project: './tsconfig.json',
        sourceType: 'module',
      },
    },
    rules: {
      ...configs.recommended.rules,
      '@typescript-eslint/comma-dangle': 'off',
      '@typescript-eslint/consistent-type-imports': [
        'warn',
        {
          prefer: 'type-imports',
          fixStyle: 'inline-type-imports',
          disallowTypeAnnotations: true,
        },
      ],
    },
  },
  {
    files: ['src/translations/*.json'],
    plugins: { 'i18n-json': i18nJsonPlugin },
    processor: {
      meta: { name: '.json' },
      ...i18nJsonPlugin.processors['.json'],
    },
    rules: {
      ...i18nJsonPlugin.configs.recommended.rules,
      'i18n-json/valid-message-syntax': [
        2,
        {
          syntax: path.resolve(
            __dirname,
            './scripts/i18next-syntax-validation.js'
          ),
        },
      ],
      'i18n-json/valid-json': 2,
      'i18n-json/sorted-keys': [
        2,
        {
          order: 'asc',
          indentSpaces: 2,
        },
      ],
      'i18n-json/identical-keys': [
        2,
        {
          filePath: path.resolve(__dirname, './src/translations/en.json'),
        },
      ],
      'prettier/prettier': [
        0,
        {
          singleQuote: true,
          endOfLine: 'auto',
        },
      ],
    },
  },
  {
    files: ['**/__tests__/**/*.[jt]s?(x)', '**/?(*.)+(spec|test).[jt]s?(x)'],
    plugins: { 'testing-library': testingLibrary },
    rules: {
      ...testingLibrary.configs.react.rules,
    },
  },
]);
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

## Git Hooks with Husky

[Section titled â€œGit Hooks with Huskyâ€](#git-hooks-with-husky)

The starter comes with a set of git hooks that help us to enforce rules and conventions. Those hooks are configured using [Husky](https://typicode.github.io/husky/#/). and here is the complete list of the hooks:

### pre-commit

[Section titled â€œpre-commitâ€](#pre-commit)

As the name suggest, this hook will run before each commit and it will make sure you are not committing directly on the main branch and it will run the linter and typescript checking on the staged files.

.husky/pre-commit

```bash
. "$(dirname "$0")/common.sh"




echo "===\n>> Checking branch name..."


# Check if branch protection is enabled
if [[ -z $SKIP_BRANCH_PROTECTION ]]; then
    BRANCH=$(git rev-parse --abbrev-ref HEAD)
    PROTECTED_BRANCHES="^(main|master)"


    if [[ $BRANCH =~ $PROTECTED_BRANCHES ]]; then
        echo ">> Direct commits to the $BRANCH branch are not allowed. Please choose a new branch name."
        exit 1
    fi
else
    echo ">> Skipping branch protection."
fi


echo ">> Finish checking branch name"
echo ">> Linting your files and fixing them if needed..."


pnpm type-check
pnpm lint-staged
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

### post-merge

[Section titled â€œpost-mergeâ€](#post-merge)

As the name suggest, this hook will run after each merge and it will check if there is any changed in pnpm-lock.yaml and if there is any, it will run `pnpm install` to make sure the dependencies are up to date.

.husky/post-merge

```bash
function changed {
    git diff --name-only HEAD@{1} HEAD | grep "^$1" >/dev/null 2>&1
}


echo 'Checking for changes in pnpm-lock.yml...'


if changed 'pnpm-lock.yml'; then
    echo "ğŸ“¦ pnpm-lock.yml changed. Run pnpm install to bring your dependencies up to date."
    pnpm install
fi


echo 'You are up to date :)'


echo 'If necessary, you can run pnpm prebuild to generate native code.'


exit 0
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

### commit-msg

[Section titled â€œcommit-msgâ€](#commit-msg)

This hook will check if the commit message is following the conventional commit format. If itâ€™s not, the commit will be aborted and will show you what going wrong with your commit message.

.husky/commit-msg

```bash
pnpm commitlint --edit $1
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

We are using [commitlint](https://commitlint.js.org/#/) to check if the commit message is following the conventional commit format.

In general, your commit message should follow this format:

```bash
type(scope?): subject  #scope is optional; multiple scopes are supported (current delimiter options: "/", "\" and ",")
```

Real world examples can look like this:

```txt
fix(ui): fix input width
feat(ui): add button variants
feat(api): add usePost query hook
```

`type` should be one of the following: build, chore, ci ,docs,feat,fix, perf, refactor, revert, style or test.

## ğŸ”— Resources

[Section titled â€œğŸ”— Resourcesâ€](#-resources)

* [Typescript for React Developers](https://elazizi.com/how-to-learn-type-script-for-react-developers)
* [Typescript](https://docs.expo.io/guides/typescript/)
* [Husky](https://typicode.github.io/husky/#/)
* [commitlint](https://commitlint.js.org/#/)
* [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/)
* [Eslint](https://eslint.org/)

# Authentication

> How to manage authentication in your app.

Most of the applications we had the chance to work on required some sort of authentication and having a bad approach to do it can lead to a lot of problems. The starter kit comes with the basics and mostly what you need to start with authentication in your application.

As Authentication is global to the application, we end up using Zustand to manage the authentication state of the application.

[Zustand](https://github.com/pmndrs/zustand) is a state management library that is very simple to use and highly performant. It is also easy to integrate with React and works better than a simple context API, as it offers additional features such as selectors to prevent unnecessary re-renders.

Zustand works very well with TypeScript and can be easily used outside the React tree, which means more flexibility.

## Authentication Store

[Section titled â€œAuthentication Storeâ€](#authentication-store)

As mentioned earlier, we use Zustand to manage the authentication state of the application. The authentication store is located in `src/store/auth` and is utilized for managing the authentication state of the application.

src/lib/auth/index.tsx

```tsx
import { create } from 'zustand';


import { createSelectors } from '../utils';
import type { TokenType } from './utils';
import { getToken, removeToken, setToken } from './utils';


interface AuthState {
  token: TokenType | null;
  status: 'idle' | 'signOut' | 'signIn';
  signIn: (data: TokenType) => void;
  signOut: () => void;
  hydrate: () => void;
}


const _useAuth = create<AuthState>((set, get) => ({
  status: 'idle',
  token: null,
  signIn: (token) => {
    setToken(token);
    set({ status: 'signIn', token });
  },
  signOut: () => {
    removeToken();
    set({ status: 'signOut', token: null });
  },
  hydrate: () => {
    try {
      const userToken = getToken();
      if (userToken !== null) {
        get().signIn(userToken);
      } else {
        get().signOut();
      }
    } catch (e) {
      // only to remove eslint error, handle the error properly
      console.error(e);
      // catch error here
      // Maybe sign_out user!
    }
  },
}));


export const useAuth = createSelectors(_useAuth);


export const signOut = () => _useAuth.getState().signOut();
export const signIn = (token: TokenType) => _useAuth.getState().signIn(token);
export const hydrateAuth = () => _useAuth.getState().hydrate();
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

The store is composed of 2 states and 3 actions:

* `status`: The status of the authentication. It can be `idle`, `signOut` or `signIn`.

  * `idle`: Still not sure if the user is authenticated or not (when we are fetching tokens from the storage)
  * `signOut`: The user is not authenticated
  * `signIn`: The user is authenticated

* `useToken`: The token of the user. It is used to authenticate the user to the API. It is stored in the storage of the device and we use it to hydrate the authentication status state when the application is started.

  For the Demo app `useToken` is a simple object that contains the `accessToken` and the `refreshToken`. You can add more fields if you update the `TokenType` type in `src/lib/auth/utils.ts`.

* `signIn`: The function performs user sign-in. It accepts a token as a parameter, sets the token state, stores it locally, and updates the status to `signIn`.

* `signOut`: The action to sign out the user. It sets the token state to `null` and removes it from the storage as well as setting the status to `signOut`.

* `hydrate`: The action to hydrate the authentication status state. We call this action when the application is started to check if the user is authenticated or not. It fetches the token from the storage and sets the status to `signIn` if the token is not `null` or `signOut` if the token is `null`.

## Use Authentication store

[Section titled â€œUse Authentication storeâ€](#use-authentication-store)

You guessed it, you only need to import the store from `@/lib` and use it in your component or even call store actions from outside React.

```tsx
import { useAuth, hydrate } from '@/lib';


hydrate(); // call this when the application is started to check if the user is authenticated or not


const App = () => {
  const status = useAuth.use.status();
  const signOut = useAuth.use.signOut();


  return (
    <View>
      <Text>{status}</Text>
      <Button title="Sign Out" onPress={signOut} />
    </View>
  );
};
```

## Use Case

[Section titled â€œUse Caseâ€](#use-case)

Letâ€™s imagine we have a simple application that has a login navigator and a home navigator. The home navigator is only accessible if the user is authenticated, while the login navigator is accessible if the user is not authenticated.

In this case, you only need to retrieve the status from the authentication store and display the appropriate navigation based on the status.

src/app/(app)/\_layout.tsx

```tsx
import { Link, Redirect, SplashScreen, Tabs } from 'expo-router';
import React, { useCallback, useEffect } from 'react';


import { Pressable, Text } from '@/components/ui';
import {
  Feed as FeedIcon,
  Settings as SettingsIcon,
  Style as StyleIcon,
} from '@/components/ui/icons';
import { useAuth, useIsFirstTime } from '@/lib';


export default function TabLayout() {
  const status = useAuth.use.status();
  const [isFirstTime] = useIsFirstTime();
  const hideSplash = useCallback(async () => {
    await SplashScreen.hideAsync();
  }, []);
  useEffect(() => {
    if (status !== 'idle') {
      setTimeout(() => {
        hideSplash();
      }, 1000);
    }
  }, [hideSplash, status]);


  if (isFirstTime) {
    return <Redirect href="/onboarding" />;
  }
  if (status === 'signOut') {
    return <Redirect href="/login" />;
  }
  return (
    <Tabs>
      <Tabs.Screen
        name="index"
        options={{
          title: 'Feed',
          tabBarIcon: ({ color }) => <FeedIcon color={color} />,
          headerRight: () => <CreateNewPostLink />,
          tabBarButtonTestID: 'feed-tab',
        }}
      />


      <Tabs.Screen
        name="style"
        options={{
          title: 'Style',
          headerShown: false,
          tabBarIcon: ({ color }) => <StyleIcon color={color} />,
          tabBarButtonTestID: 'style-tab',
        }}
      />
      <Tabs.Screen
        name="settings"
        options={{
          title: 'Settings',
          headerShown: false,
          tabBarIcon: ({ color }) => <SettingsIcon color={color} />,
          tabBarButtonTestID: 'settings-tab',
        }}
      />
    </Tabs>
  );
}


const CreateNewPostLink = () => {
  return (
    <Link href="/feed/add-post" asChild>
      <Pressable>
        <Text className="text-primary-300 px-3">Create</Text>
      </Pressable>
    </Link>
  );
};
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

# Data Fetching

> Learn how to fetch data from a server using react-query and axios.

From the beginning of React, the community has been building a rich ecosystem of tools and libraries that help you build your applications. One of the most important parts of this ecosystem is the ability to fetch data from a server and display it in your application.

While there are numerous options available for fetching data in React and React Native, the community has recently been gravitating towards adopting React Query as the go-to solution. The reason for this trend is due to React Queryâ€™s simplicity, flexibility, and tone of features that it provides out of the box.

## What is react-query?

[Section titled â€œWhat is react-query?â€](#what-is-react-query)

[React-query](https://tanstack.com/query/v4/docs/overview) It is a very powerful library that helps you manage your data fetching, caching, invalidating, and even implementing optimistic UI in a very simple way.

`react-query` offers hooks that simplify the process of fetching and updating data in your app. You can use pre-built hooks like `useQuery` and `useMutation`, or create your own custom hooks based on them. This makes it easier for developers to manage data and build more efficient applications.

## Using react-query-kit & axios

[Section titled â€œUsing react-query-kit & axiosâ€](#using-react-query-kit--axios)

As the starter is designed to save you time and effort, we already have installed react-query and Axios and configured them for you.

The `src/api` folder contains all the fetching logic, with a `common` sub-folder that holds a `client`, `queryClient`, and several utility functions specifically designed to work with `react-query`.

Because weâ€™re using Axios as the client, we can leverage all its advanced features, including interceptors, request cancellation, and more. For additional information on Axios, you can check out their website [here](https://axios-http.com/).

To make writing queries and mutation even easier we are using [react-query-kit](https://github.com/liaoliao666/react-query-kit), a simple toolkit that makes ReactQuery reusable and type-safe with less boilerplate.

Tip

You recommend reading Those guides and checking those resources to learn more about react-query:

* [React-query](https://tanstack.com/query/v4/docs/overview)
* [react-query-kit](https://github.com/liaoliao666/react-query-kit)
* [Practical React Query](https://tkdodo.eu/blog/practical-react-query)

## Data Fetching Use Cases

[Section titled â€œData Fetching Use Casesâ€](#data-fetching-use-cases)

Suppose youâ€™re building a blog app and need to add the following features:

* A Feed Screen that displays all posts
* A Post Screen that shows the details of a single post
* A Screen to create a new post

To get started, create a new folder named `posts` within `src/api`. This folder will hold all the post-related logic. You can apply this same concept to any other entities, such as users, within your application.

### Feed Screen

[Section titled â€œFeed Screenâ€](#feed-screen)

The feed screen will show all the posts available in the app. To achieve this, we need to create a hook called `usePosts` that will fetch the posts and display them as a list.

Here are the steps to create the `usePosts` hook:

1. Inside the `src/api/posts` folder, create a new file called `use-posts.ts`.
2. Define the type for your `Response` and `Variables` if required, to ensure that you receive the correct data from the server. For instance, you could create a `Post` type for the posts.
3. Use the `createQuery` function from `react-query-kit` library to create a query hook that will fetch the data from the server. Weâ€™ll name it `usePosts` hook.

Below is the complete code for the use-posts.ts file:

src/api/posts/use-posts.ts

```ts
import type { AxiosError } from 'axios';
import { createQuery } from 'react-query-kit';


import { client } from '../common';
import type { Post } from './types';


type Response = Post[];
type Variables = void; // as react-query-kit is strongly typed, we need to specify the type of the variables as void in case we don't need them


export const usePosts = createQuery<Response, Variables, AxiosError>({
  queryKey: ['posts'],
  fetcher: () => {
    return client.get(`posts`).then((response) => response.data.posts);
  },
});
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

the `createQuery` function accept an object with the following: `queryKey`, `fetcher` and `options`. Since we migrated to the latest version of `react-query-kit`, the `queryFn` property is replaced with `fetcher` and the `queryKey` structure is simplified. Read more about (createQuery)\[<https://github.com/liaoliao666/react-query-kit#createQuery>]

Tip

Use `useq` snippet to generate a query in no time using VSCode ![use-query](https://github.com/obytes/react-native-template-obytes/assets/114411010/c052a0ee-8fba-436a-950f-a0c7e44cf3ae)

Now that we have created our custom hook, we can use it in our app to display a list of posts. Follow the steps below to achieve this:

1. Create a new screen in your app and name it Posts.
2. Import and use the usePosts hook we created earlier to fetch the list of posts.
3. Use the fetched data to display a list of posts.

src/app/(app)/index.tsx

```tsx
import { FlashList } from '@shopify/flash-list';
import React from 'react';


import type { Post } from '@/api';
import { usePosts } from '@/api';
import { Card } from '@/components/card';
import { EmptyList, FocusAwareStatusBar, Text, View } from '@/components/ui';


export default function Feed() {
  const { data, isPending, isError } = usePosts();
  const renderItem = React.useCallback(
    ({ item }: { item: Post }) => <Card {...item} />,
    []
  );


  if (isError) {
    return (
      <View>
        <Text> Error Loading data </Text>
      </View>
    );
  }
  return (
    <View className="flex-1">
      <FocusAwareStatusBar />
      <FlashList
        data={data}
        renderItem={renderItem}
        keyExtractor={(_, index) => `item-${index}`}
        ListEmptyComponent={<EmptyList isLoading={isPending} />}
      />
    </View>
  );
}
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

As you can see in the code above, we use the `usePosts` hook to fetch data and handle the loading state. This allows us to display a loading indicator while the data is being fetched, and then display the list of posts once the data is ready.

In the same example above we also show an error message if the request fails.

### Post Screen

[Section titled â€œPost Screenâ€](#post-screen)

The post screen will display the details of a single post. To fetch and display the post, we will create a new hook called `usePost`.

We can use the same steps we used earlier to create the `usePosts` hook. The only difference is that we will use the `id` of the post as a variable to fetch the specific post.

Below is the complete code for the `use-post.ts` file:

src/api/posts/use-post.ts

```ts
import type { AxiosError } from 'axios';
import { createQuery } from 'react-query-kit';


import { client } from '../common';
import type { Post } from './types';


type Variables = { id: string };
type Response = Post;


export const usePost = createQuery<Response, Variables, AxiosError>({
  queryKey: ['posts'],
  fetcher: (variables) => {
    return client
      .get(`posts/${variables.id}`)
      .then((response) => response.data);
  },
});
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

Now our hook is ready to be used in our post details screen:

src/app/feed/\[id].tsx

```tsx
import { Stack, useLocalSearchParams } from 'expo-router';
import * as React from 'react';


import { usePost } from '@/api';
import {
  ActivityIndicator,
  FocusAwareStatusBar,
  Text,
  View,
} from '@/components/ui';


export default function Post() {
  const local = useLocalSearchParams<{ id: string }>();


  const { data, isPending, isError } = usePost({
    //@ts-ignore
    variables: { id: local.id },
  });


  if (isPending) {
    return (
      <View className="flex-1 justify-center p-3">
        <Stack.Screen options={{ title: 'Post', headerBackTitle: 'Feed' }} />
        <FocusAwareStatusBar />
        <ActivityIndicator />
      </View>
    );
  }
  if (isError) {
    return (
      <View className="flex-1 justify-center p-3">
        <Stack.Screen options={{ title: 'Post', headerBackTitle: 'Feed' }} />
        <FocusAwareStatusBar />
        <Text className="text-center">Error loading post</Text>
      </View>
    );
  }


  return (
    <View className="flex-1 p-3">
      <Stack.Screen options={{ title: 'Post', headerBackTitle: 'Feed' }} />
      <FocusAwareStatusBar />
      <Text className="text-xl">{data.title}</Text>
      <Text>{data.body} </Text>
    </View>
  );
}
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

### Add new post

[Section titled â€œAdd new postâ€](#add-new-post)

To add a new post, we can use the `createMutation` function from the `react-query-kit` library.

Here are the steps to create the useAddPost hook:

1. Create a new file called `use-add-post.ts` inside the `src/api/posts` folder.
2. Define a type for your `Variables` and `Response` to ensure that you are sending the correct data to the server.
3. Use the `createMutation` function from `react-query-kit` library to create a mutation hook that will send the data to the server. Weâ€™ll name this hook `useAddPost`.

Here is the complete code for the `use-add-post.ts` file:

src/api/posts/use-add-post.ts

```ts
import type { AxiosError } from 'axios';
import { createMutation } from 'react-query-kit';


import { client } from '../common';
import type { Post } from './types';


type Variables = { title: string; body: string; userId: number };
type Response = Post;


export const useAddPost = createMutation<Response, Variables, AxiosError>({
  mutationFn: async (variables) =>
    client({
      url: 'posts/add',
      method: 'POST',
      data: variables,
    }).then((response) => response.data),
});
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

Tip

Use `usem` snippet to generate mutation in no time using VSCode

Now that we have our mutation hook ready. Letâ€™s create a new screen called `AddPost` and use data from `useAddPost` hook to create a new post:

Exactly the same way we did in [form section](/ui-and-theme/forms) while creating a login form, we will follow the same approach to create a from to create a new post.

1. Create the schema for the new form using Zod
2. Create the form using react-hook-form
3. Get `mutate` function from `useAddPost` hook and call it when the form is submitted
4. You can use the `isPending` state to display a loading indicator while the data is being sent to the server and then redirect the user to the feed screen on success.

src/app/feed/add-post.tsx

```tsx
import { zodResolver } from '@hookform/resolvers/zod';
import { Stack } from 'expo-router';
import * as React from 'react';
import { useForm } from 'react-hook-form';
import { showMessage } from 'react-native-flash-message';
import { z } from 'zod';


import { useAddPost } from '@/api';
import {
  Button,
  ControlledInput,
  showErrorMessage,
  View,
} from '@/components/ui';


const schema = z.object({
  title: z.string().min(10),
  body: z.string().min(120),
});


type FormType = z.infer<typeof schema>;


export default function AddPost() {
  const { control, handleSubmit } = useForm<FormType>({
    resolver: zodResolver(schema),
  });
  const { mutate: addPost, isPending } = useAddPost();


  const onSubmit = (data: FormType) => {
    console.log(data);
    addPost(
      { ...data, userId: 1 },
      {
        onSuccess: () => {
          showMessage({
            message: 'Post added successfully',
            type: 'success',
          });
          // here you can navigate to the post list and refresh the list data
          //queryClient.invalidateQueries(usePosts.getKey());
        },
        onError: () => {
          showErrorMessage('Error adding post');
        },
      }
    );
  };
  return (
    <>
      <Stack.Screen
        options={{
          title: 'Add Post',
          headerBackTitle: 'Feed',
        }}
      />
      <View className="flex-1 p-4">
        <ControlledInput
          name="title"
          label="Title"
          control={control}
          testID="title"
        />
        <ControlledInput
          name="body"
          label="Content"
          control={control}
          multiline
          testID="body-input"
        />
        <Button
          label="Add Post"
          loading={isPending}
          onPress={handleSubmit(onSubmit)}
          testID="add-post-button"
        />
      </View>
    </>
  );
}
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

## Create API Hooks with Vs Code Snippets

[Section titled â€œCreate API Hooks with Vs Code Snippetsâ€](#create-api-hooks-with-vs-code-snippets)

Maybe you mentioned that creating a new query or mutation hook looks the same every time and you are right. That is why we created a set of vscode snippets to help you create your hooks in no time.

* `useq` : Create a new query hook

![use-query](https://github.com/obytes/react-native-template-obytes/assets/114411010/c052a0ee-8fba-436a-950f-a0c7e44cf3ae)

* `useqv` : Create a new query hook with variables

* `useiq` : Create a new infinite query hook

* `usem` : Create a new mutation hook

![use-mutation](https://github.com/obytes/react-native-template-obytes/assets/11137944/c322f827-b71d-4629-a337-eb7cd96d4125)

## React Query dev tools plugin

[Section titled â€œReact Query dev tools pluginâ€](#react-query-dev-tools-plugin)

For managing and and monitoring the `React Query` instances, we use the [React Query dev tools plugin](https://docs.expo.dev/debugging/devtools-plugins/#react-query), which offers us visibility into our data fetching processes and caching in real-time. It gives the ability to refetch the data manually, inspect and remove queries, providing control over our data. To use it, in the terminal press `shift` + `m` and choose from the opened list of dev tools the React Query plugin. The pluginâ€™s web interface will open and display the queries, enabling efficient debugging like in the example below:

![React Query plugin web interface](https://github.com/obytes/react-native-template-obytes/assets/114411010/26bc96ef-e6cb-49c3-be3c-006d6901e440)

# Internationalization

> How to add internationalization to your app.

The starter comes with a basic internationalization setup. It uses [expo-localization](https://docs.expo.dev/guides/localization/) and [i18next](https://www.i18next.com/) to provide a simple way to translate your app.

## Adding a new language

[Section titled â€œAdding a new languageâ€](#adding-a-new-language)

Mainly the demo app supports two languages: English and Arabic (RTL). You can add more languages by adding the translation files in the `src/translations` folder and adding the language code to the `src/lib/i18n/resources.ts` file.

src/lib/i18n/resources.ts

```ts
import ar from '@/translations/ar.json';
import en from '@/translations/en.json';


export const resources = {
  en: {
    translation: en,
  },
  ar: {
    translation: ar,
  },
};


export type Language = keyof typeof resources;
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

Tip

Anything related to internationalization should be found in the `src/lib/i18n` folder.

## Using translations in your app

[Section titled â€œUsing translations in your appâ€](#using-translations-in-your-app)

The i18n core module provides a set of utility functions to help you use translation in your app.

* `useTranslation` hook from `react-i18next`: to get the translation function.

```tsx
import React from 'react';
import { useTranslation } from 'react-i18next';


import { Text } from '@/components/ui';


export const Foo = () => {
  const { t } = useTranslation();
  return (
    <>
      <Text className="text-center">{t('settings.language')}</Text>
    </>
  );
};
```

or as `Text` component comes with translation support, you can easily use it as follows:

```tsx
import React from 'react';


import { Text } from '@/components/ui';


export const Foo = () => {
  return <Text className="text-center" tx="settings.language" />;
};
```

* `useSetLanguage` hook: to change the current language. This hook returns the selected language and a function to change the language.

Additionally, the `useSetLanguage` hook will save the selected language in device storage using `MMKV` and will be used as the default language when the app is opened again As well as adding some extra config for RTL languages while updating the selected language.

src/lib/i18n/utils.tsx

```tsx
import type TranslateOptions from 'i18next';
import i18n from 'i18next';
import memoize from 'lodash.memoize';
import { useCallback } from 'react';
import { I18nManager, NativeModules, Platform } from 'react-native';
import { useMMKVString } from 'react-native-mmkv';
import RNRestart from 'react-native-restart';


import { storage } from '../storage';
import type { Language, resources } from './resources';
import type { RecursiveKeyOf } from './types';


type DefaultLocale = typeof resources.en.translation;
export type TxKeyPath = RecursiveKeyOf<DefaultLocale>;


export const LOCAL = 'local';


export const getLanguage = () => storage.getString(LOCAL); // 'Marc' getItem<Language | undefined>(LOCAL);


export const translate = memoize(
  (key: TxKeyPath, options = undefined) =>
    i18n.t(key, options) as unknown as string,
  (key: TxKeyPath, options: typeof TranslateOptions) =>
    options ? key + JSON.stringify(options) : key
);


export const changeLanguage = (lang: Language) => {
  i18n.changeLanguage(lang);
  if (lang === 'ar') {
    I18nManager.forceRTL(true);
  } else {
    I18nManager.forceRTL(false);
  }
  if (Platform.OS === 'ios' || Platform.OS === 'android') {
    if (__DEV__) NativeModules.DevSettings.reload();
    else RNRestart.restart();
  } else if (Platform.OS === 'web') {
    window.location.reload();
  }
};


export const useSelectedLanguage = () => {
  const [language, setLang] = useMMKVString(LOCAL);


  const setLanguage = useCallback(
    (lang: Language) => {
      setLang(lang);
      if (lang !== undefined) changeLanguage(lang as Language);
    },
    [setLang]
  );


  return { language: language as Language, setLanguage };
};
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

## Robust translation

[Section titled â€œRobust translationâ€](#robust-translation)

**Typescript support**

To make the translation for your app more robust and easy to maintain, we have added TypeScript support for the translation function. This ensures that you are using the correct translation key and provide auto-completion for the translation keys. Here is an example of the error you will get if you are using the wrong translation key.

![typescript-translation](https://github.com/obytes/react-native-template-obytes/assets/11137944/80a7a0fd-a6f8-4d31-a450-46de797ebdc6)

## Eslint rules

[Section titled â€œEslint rulesâ€](#eslint-rules)

We have also added ESLint rules to ensure that your translation file resources are always up to date. These rules will run as a pre-commit hook whenever you attempt to commit changes to the translation files.

We utilize [eslint-plugin-i18n-json](https://github.com/godaddy/eslint-plugin-i18n-json) alongside a customized validation script for i18next. This script helps sort keys, ensures that all resource files are identical and prevents any missing translations.

# Expo Router

> How to use Expo Router in your app.

[expo-router](https://docs.expo.dev/router/introduction/) is a navigation library provided by Expo that simplifies the implementation of navigation in React Native applications. It is built on top of React Navigation, a widely used navigation library, and abstracts away much of the complexity involved in managing navigation state and transitions between screens.

Navigation in Expo Router is expressed declaratively, utilizing components to define the flow of the application. This approach makes it intuitive for developers to structure their navigation hierarchy.

Conventional React Native projects typically adopt a structure where a sole root component is commonly specified in either ./App.js or ./index.js. Within the context of Expo Router, an alternative approach is offered through the utilization of the Root Layout, located in `app/_layout.tsx` in our Demo. Thereby, the `_layout` section of our app handles the overall structure and navigation setup.

src/app/\_layout.tsx

```tsx
// Import  global CSS file
import '../../global.css';


import {
  Inter_400Regular,
  Inter_500Medium,
  Inter_600SemiBold,
  Inter_700Bold,
  useFonts,
} from '@expo-google-fonts/inter';
import { BottomSheetModalProvider } from '@gorhom/bottom-sheet';
import { Stack } from 'expo-router';
import * as SplashScreen from 'expo-splash-screen';
import { HeroUINativeProvider } from 'heroui-native';
import React, { useCallback } from 'react';
import { KeyboardAvoidingView, StyleSheet } from 'react-native';
import FlashMessage from 'react-native-flash-message';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { KeyboardProvider } from 'react-native-keyboard-controller';
import {
  configureReanimatedLogger,
  ReanimatedLogLevel,
} from 'react-native-reanimated';


import { APIProvider } from '@/api';
import { hydrateAuth } from '@/lib';
import { AppThemeProvider } from '@/lib/contexts/app-theme-context';


export { ErrorBoundary } from 'expo-router';


configureReanimatedLogger({
  level: ReanimatedLogLevel.warn,
  strict: false,
});


export const unstable_settings = {
  initialRouteName: '(app)',
};


hydrateAuth();
// Prevent the splash screen from auto-hiding before asset loading is complete.
SplashScreen.preventAutoHideAsync();
// Set the animation options. This is optional.
SplashScreen.setOptions({
  duration: 500,
  fade: true,
});


export default function RootLayout() {
  const fonts = useFonts({
    Inter_400Regular,
    Inter_500Medium,
    Inter_600SemiBold,
    Inter_700Bold,
  });


  if (!fonts) {
    return null;
  }


  return (
    <Providers>
      <Stack>
        <Stack.Screen name="(app)" options={{ headerShown: false }} />
        <Stack.Screen name="onboarding" options={{ headerShown: false }} />
        <Stack.Screen name="login" options={{ headerShown: false }} />
      </Stack>
    </Providers>
  );
}


const Providers: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const contentWrapper = useCallback(
    (children: React.ReactNode) => (
      <KeyboardAvoidingView
        pointerEvents="box-none"
        behavior="padding"
        keyboardVerticalOffset={12}
        className="flex-1"
      >
        {children}
      </KeyboardAvoidingView>
    ),
    []
  );


  return (
    <GestureHandlerRootView style={styles.container}>
      <KeyboardProvider>
        <AppThemeProvider>
          <HeroUINativeProvider
            config={{
              toast: {
                contentWrapper,
              },
            }}
          >
            <APIProvider>
              <BottomSheetModalProvider>
                {children}
                <FlashMessage position="top" />
              </BottomSheetModalProvider>
            </APIProvider>
          </HeroUINativeProvider>
        </AppThemeProvider>
      </KeyboardProvider>
    </GestureHandlerRootView>
  );
};


const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
});
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

The Demo app comes with a simple stack and tabs layout. Feel free to remove what is not working for you and add your own using the same approach as the existing ones.

Here is a simple example of the tabs layout.

src/app/(app)/\_layout.tsx

```tsx
import { Link, Redirect, SplashScreen, Tabs } from 'expo-router';
import React, { useCallback, useEffect } from 'react';


import { Pressable, Text } from '@/components/ui';
import {
  Feed as FeedIcon,
  Settings as SettingsIcon,
  Style as StyleIcon,
} from '@/components/ui/icons';
import { useAuth, useIsFirstTime } from '@/lib';


export default function TabLayout() {
  const status = useAuth.use.status();
  const [isFirstTime] = useIsFirstTime();
  const hideSplash = useCallback(async () => {
    await SplashScreen.hideAsync();
  }, []);
  useEffect(() => {
    if (status !== 'idle') {
      setTimeout(() => {
        hideSplash();
      }, 1000);
    }
  }, [hideSplash, status]);


  if (isFirstTime) {
    return <Redirect href="/onboarding" />;
  }
  if (status === 'signOut') {
    return <Redirect href="/login" />;
  }
  return (
    <Tabs>
      <Tabs.Screen
        name="index"
        options={{
          title: 'Feed',
          tabBarIcon: ({ color }) => <FeedIcon color={color} />,
          headerRight: () => <CreateNewPostLink />,
          tabBarButtonTestID: 'feed-tab',
        }}
      />


      <Tabs.Screen
        name="style"
        options={{
          title: 'Style',
          headerShown: false,
          tabBarIcon: ({ color }) => <StyleIcon color={color} />,
          tabBarButtonTestID: 'style-tab',
        }}
      />
      <Tabs.Screen
        name="settings"
        options={{
          title: 'Settings',
          headerShown: false,
          tabBarIcon: ({ color }) => <SettingsIcon color={color} />,
          tabBarButtonTestID: 'settings-tab',
        }}
      />
    </Tabs>
  );
}


const CreateNewPostLink = () => {
  return (
    <Link href="/feed/add-post" asChild>
      <Pressable>
        <Text className="text-primary-300 px-3">Create</Text>
      </Pressable>
    </Link>
  );
};
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

Make sure to check the official docs for more information and examples about [expo-router](https://docs.expo.dev/router/introduction/).

# Storage

> Storage guide with mmkv library

# Storage

[Section titled â€œStorageâ€](#storage)

The starter comes with a simple storage module that uses [react-native-mmkv](https://github.com/mrousavy/react-native-mmkv) to store data in a key-value format. We also added a simple storage utility to assist you in using the storage module.

src/lib/storage.tsx

```tsx
import { MMKV } from 'react-native-mmkv';


export const storage = new MMKV();


export function getItem<T>(key: string): T | null {
  const value = storage.getString(key);
  return value ? JSON.parse(value) || null : null;
}


export async function setItem<T>(key: string, value: T) {
  storage.set(key, JSON.stringify(value));
}


export async function removeItem(key: string) {
  storage.delete(key);
}
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

The `react-native-mmkv` library provides various features such as using hooks and adding encryption to stored data. Feel free to check the [official docs](https://github.com/mrousavy/react-native-mmkv) for more information.

# Upgrading project dependencies

> How to update your project dependencies

Note

Please note that this guide is intended for updating your project dependencies only, and it does not ensure that your project will be in sync with the latest version of the starter.

To take advantage of the latest improvements in the starter project, you will need to compare your `osMetadata.initVersion` with the latest release on GitHub, and manually apply any necessary changes to your project.

## Easy way ğŸš€

[Section titled â€œEasy way ğŸš€â€](#easy-way)

Upgrading a React Native project to the latest version can be a challenging task. However, as we are using Expo with a custom dev client, the upgrade process is relatively straightforward compared to a bare React Native project, which requires a significant amount of manual work.

To update most of the dependencies that come with the starter, you can follow these simple steps:

First, go to GitHub and compare your `osMetadata.initVersion` in your `package.json` with the latest release. Check if the `package.json` has been updated. Then, copy the new dependencies and devDependencies versions and paste them into your package.json file.

Finally, run the following commands to make sure everything is working as expected:

```bash
rm -rf node_modules ## remove node_modules folder
pnpm install ## install new dependencies
pnpm run doctor ## check for any issues with the dependencies you added to your project
pnpm lint ## linting
pnpm type-check ## type checking
pnpm test ## tests
pnpm prebuild --clean ## clean ios and android build folders and regenerate them
pnpm ios ## run ios build
pnpm android ## run android build
pnpm start -c ## start the server
```

If your starter version does not have the `osMetadata.initVersion` property, donâ€™t worry. Simply follow the steps in the rest of this guide to upgrade your project.

Moreover, if you have added new dependencies to your project (which is common for most projects), the remaining sections of this guide will also assist you in upgrading your projectâ€™s dependencies.â€

## Upgrade Expo

[Section titled â€œUpgrade Expoâ€](#upgrade-expo)

Visit the npm package registry [here](https://www.npmjs.com/package/expo) to ensure that you are getting the latest version of Expo.

Once you have confirmed that you have the latest version, open your terminal and enter the following command:

```bash
pnpm add expo@latest
## pnpm add expo@48.0.5 for example
```

Thanks to the amazing work of the expo team, you can run the following command to upgrade your dependencies to match the correct version required by Expo last version.

```bash
pnpm expo install --fix
```

Running the command above will update your dependencies to ensure that they match the version requirements of Expo. In some cases, you may need to manually apply changes to your project in order to make it work with the new version. The command may also provide more detailed information on any necessary changes.

After updating your dependencies, run expo doctor to identify and fix any other issues that may be related to the new version of Expo and your devDependencies.

```bash
pnpm run doctor ## a script inside the starter
```

Running this command will generate a list of issues that require manual attention. In addition, it will provide a set of npm packages that need to be updated with the exact version required by the new version of Expo.

Now itâ€™s time to make sure everything is still working as expected ğŸ˜€:

```bash
rm -rf node_modules ## remove node_modules folder
pnpm install ## install new dependencies
pnpm lint ## linting
pnpm type-check ## type checking
pnpm test ## tests
pnpm prebuild --clean ## clean ios and android build folders and regenerate them
pnpm ios ## run ios build
pnpm android ## run android build
pnpm start -c ## start the server
```

Unfortunately, there is no magic trick here in case you have any issues while running your checks, Fixing those errors may require some manual effort. You can start by reading the error message and identifying any relevant packages that may be causing the issue. Check the changelog of those packages to see if there have been any recent updates that might have introduced breaking changes. This will help you to pinpoint the root cause of the issue and take the necessary steps to resolve it.

The only rule here is to make sure that your project is working as expected before pushing your changes to the remote repository.

Tip

Upgrading your project regularly can make the process much easier. We recommend upgrading your project a month after each new Expo major version is released. This will help you stay up to date with the latest features and security updates while minimizing the risk of encountering compatibility issues with older versions of Expo.

## Upgrade Non Native dependencies

[Section titled â€œUpgrade Non Native dependenciesâ€](#upgrade-non-native-dependencies)

While Expo upgrade will help you update most native dependencies automatically through the process outlined above, itâ€™s important to keep in mind that non-native dependencies(JS only) may also need to be updated.

This time you will use the power of pnpm to update dependencies to the last version and then run our checks to make sure everything is working as expected.

First, run the following command:

```bash
pnpm up -i
```

When you run this command, it will generate a list of all dependencies associated with your project. You will then be prompted to select the dependencies that you want to update.

```bash
â—¯ zod                               latest  3.19.1   â¯  3.21.4   https://zod.dev
â—¯ zustand                           latest  4.1.4    â¯  4.3.6    https://github.com/pmndrs/zustand


 devDependencies
   name                              range   from        to       url
 â—¯ @babel/core                       latest  7.20.2   â¯  7.21.0   https://babel.dev/docs/en/next/babel-core
 â—¯ @commitlint/cli                   latest  17.2.0   â¯  17.4.4   https://commitlint.js.org/
 â—¯ @commitlint/config-conventional   latest  17.2.0   â¯  17.4.4   https://commitlint.js.org/
 â—¯ @testing-library/jest-native      latest  5.1.2    â¯  5.4.2    https://github.com/testing-library/jest-native#readme
 â—¯ @testing-library/react-native     latest  11.4.0   â¯  11.5.3   https://callstack.github.io/react-native-testing-library
 â—¯ @types/i18n-js                    latest  3.8.3    â¯  3.8.4    https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/i18n-js
 â—¯ @types/jest                       latest  29.2.2   â¯  29.4.0   https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/jest
 â—¯ @types/react-native               latest  0.70.6   â¯  0.71.3   https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react-native
â¯â—¯ @typescript-eslint/eslint-plugin  latest  5.42.1   â¯  5.54.1   https://github.com/typescript-eslint/typescript-eslint#readme
 â—¯ @typescript-eslint/parser         latest  5.42.1   â¯  5.54.1   https://github.com/typescript-eslint/typescript-eslint#readme
 â—¯ babel-plugin-module-resolver      latest  4.1.0    â¯  5.0.0    https://github.com/tleunen/babel-plugin-module-resolver#readme
 â—¯ eslint                            latest  8.27.0   â¯  8.35.0   https://eslint.org
 â—¯ eslint-plugin-i18n-json           latest  3.1.0    â¯  4.0.0    https://github.com/godaddy/eslint-plugin-i18n-json#readme
 â—¯ eslint-plugin-simple-import-sort  latest  8.0.0    â¯  10.0.0   https://github.com/lydell/eslint-plugin-simple-import-sort#readme
 â—¯ eslint-plugin-tailwindcss         latest  3.6.2    â¯  3.10.1   https://github.com/francoismassart/eslint-plugin-tailwindcss
 â—¯ eslint-plugin-unicorn             latest  43.0.2   â¯  46.0.0   https://github.com/sindresorhus/eslint-plugin-unicorn#readme
```

There is no one-size-fits-all solution for managing updates to your projectâ€™s dependencies. However, we recommend reviewing the changelog of each package and paying particular attention to any major version updates (indicated by red text). Major version updates may introduce breaking changes that could potentially affect your projectâ€™s functionality.

We recommend to start updating `devDependencies` first by following this process:

1. Select all `devDependencies` and update them to the latest version.
2. Run `pnpm doctor` to revert any changes that are not in sync with the Expo version you are using.
3. Run your checks to make sure everything is working as expected.

```bash
rm -rf node_modules ## remove node_modules folder
pnpm install ## install new dependencies
pnpm lint ## linting
pnpm type-check ## type checking
pnpm test ## tests
pnpm prebuild --clean ## clean ios and Android build folders and regenerate them
pnpm ios ## run ios build
pnpm android ## run android build
pnpm start -c ## start the server
```

If you are lucky enough and everything works as expected without any issues, you can now update the rest of the dependencies.

Tip

In case your application is not tested enough, itâ€™s a good idea to take some time to go through the application and ensure that the most critical features are working correctly before committing any changes.

# How to Contribute

> How to contribute to the project, including ways to show your support, report bugs, and more.

Thank you for your interest in contributing to our project. Your involvement is greatly appreciated and we welcome your contributions. Here are some ways you can help us improve this project:

1. Show your support for the project by giving it a ğŸŒŸ on [Github](https://github.com/obytes/react-native-template-obytes). This helps us increase visibility and attract more contributors.
2. Share your thoughts and ideas with us by [opening an issue](https://github.com/obytes/react-native-template-obytes/issues). If you have any suggestions or feedback about any aspect of the project, we are always eager to hear from you and have a [discussion](https://github.com/obytes/react-native-template-obytes/discussions).
3. If you have any questions about the project, please donâ€™t hesitate to ask. Simply open a new [QA discussion](https://github.com/obytes/react-native-template-obytes/discussions/categories/q-a) and our team will do our best to provide a helpful and informative response.
4. If you encounter a bug or typo while using the starter kit or reading the documentation, we would be grateful if you could bring it to our attention. You can open an issue to report the issue, or even better, submit a pull request with a fix.

We value the input and contributions of our community and look forward to working with you to improve this project.

# Libraries Recommendation

> React Native / Expo Libraries recommendation for the project based on use cases.

The starter kit comes with a set of pre-installed and configured libraries. We recommend using these libraries for your project.

Below, weâ€™ll list other libraries we often use in our projects. These arenâ€™t included in the starter because:

1. Theyâ€™re for specific use cases.
2. They need a lot of setup.

This way, you can add them to your project only if you need them, keeping things simple to start with.

### State Management:

[Section titled â€œState Management:â€](#state-management)

The starter kit comes with Zustand out of the box but if your application implements a lot of workflows, you might want to use [XState](https://xstate.js.org/) as itâ€™s more powerful on managing complex workflows and state machines.

For example, if you have a workflow to create a new card for user and this workflow has a lot of steps and conditions, Zustand might not be the best choice as itâ€™s more designed for simple state management and XState is your best choice in this case.

### Error Reporting:

[Section titled â€œError Reporting:â€](#error-reporting)

* [Sentry](https://sentry.io/welcome/): very popular solution for error reporting in the javascript ecosystem and has a great integration with Expo.

### Notifications:

[Section titled â€œNotifications:â€](#notifications)

There is no solution fit all for notifications, but based on your use case we would recommend one of the following:

* [Expo Push Notifications](https://docs.expo.dev/push-notifications/overview/)
* [OneSignal](https://onesignal.com/)

### Analytics:

[Section titled â€œAnalytics:â€](#analytics)

* [PostHog](https://posthog.com/docs/libraries/react-native) : Easy to setup and use and has a great free tier.

* [Google Analytics](https://rnfirebase.io/analytics/usage)

### Charts:

[Section titled â€œCharts:â€](#charts)

* [Victory Native](https://github.com/FormidableLabs/victory-native-xl)

***

For sure we are missing some great libraries here, so we count on your contribution to add them in the comments sections below.

# Overview

> An overview of why we built this starter, including its features, the libraries used, and more.

Welcome to the Obytes Mobile Tribeâ€™s Expo / React Native Starter Kit!

## ğŸš€ Motivation

[Section titled â€œğŸš€ Motivationâ€](#-motivation)

Our goal with this starter kit was to streamline the process of building React Native apps, both for our own team and for our clients. We wanted to create a resource that would allow us to create high-quality apps faster and with less effort, while ensuring that all of our projects adhere to the same code standards and architectural principles.

The benefits of using this starter kit are numerous. It helps our team easily switch between projects, as we can rely on a consistent foundation of code. It also allows us to focus on the business logic of each project rather than getting bogged down in boilerplate code. And, because it promotes consistency across projects, it makes it easier to maintain and scale our apps, as well as share code between teams.

Overall, our starter kit is designed to facilitate efficient and effective app development, helping us to bring the best possible products to our clients

## âœï¸ Philosophy

[Section titled â€œâœï¸ Philosophyâ€](#ï¸-philosophy)

When creating this starter kit, we had several guiding principles in mind::

* **ğŸš€ Production-ready**: We wanted to ensure that this starter was ready for real-world use, providing a solid foundation for building production-grade apps.
* **ğŸ¥· Developer experience and productivity**: Our focus was on creating a starter that would enhance the developer experience and increase productivity.
* **ğŸ§© Minimal code and dependencies**: We aimed to keep the codebase and dependencies as small as possible.
* **ğŸ’ª Well-maintained third-party libraries**: We included only well-maintained and reliable third-party libraries, to provide stability and support for our projects.

## â­ Key Features

[Section titled â€œâ­ Key Featuresâ€](#-key-features)

* âœ… Latest Expo SDK with Custom Dev Client: Leverage the best of the Expo ecosystem while maintaining full control over your app.
* ğŸ‰ [TypeScript](https://www.typescriptlang.org/) for enhanced code quality and bug prevention through static type checking.
* ğŸ’… Minimal UI kit built with [TailwindCSS](https://www.nativewind.dev/), featuring common components essential for your app.
* âš™ï¸ Multi-environment build support (Production, Staging, Development) using Expo configuration.
* ğŸ¦Š Husky for Git Hooks: Automate your git hooks and enforce code standards.
* ğŸ’¡ Clean project structure with Absolute Imports for easier code navigation and management.
* ğŸš« Lint-staged: Run Eslint and TypeScript checks on Git staged files to maintain code quality.
* ğŸ—‚ VSCode recommended extensions, settings, and snippets for an enhanced developer experience.
* â˜‚ï¸ Pre-installed [Expo Router](https://docs.expo.dev/router/introduction/) with examples for comprehensive app navigation.
* ğŸ’« Auth flow implementation using [Zustand](https://github.com/pmndrs/zustand) for state management and [react-native-mmkv](https://github.com/mrousavy/react-native-mmkv) for secure data storage.
* ğŸ›  10+ [Github Actions](https://github.com/features/actions) workflows for building, releasing, testing, and distributing your app.
* ğŸ”¥ [React Query](https://react-query.tanstack.com/) and [axios](https://github.com/axios/axios) for efficient data fetching and state management.
* ğŸ§µ Robust form handling with [react-hook-form](https://react-hook-form.com/) and [zod](https://github.com/colinhacks/zod) for validation, plus keyboard handling.
* ğŸ¯ Localization support with [i18next](https://www.i18next.com/), including Eslint for validation.
* ğŸ§ª Unit testing setup with [Jest](https://jestjs.io/) and [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/).
* ğŸ” E2E testing capabilities with [Maestro](https://maestro.mobile.dev/) for comprehensive app testing.

## ğŸ¤” Is this starter for me?

[Section titled â€œğŸ¤” Is this starter for me?â€](#-is-this-starter-for-me)

Yes ğŸ˜€

This starter kit is designed to benefit a wide range of React Native developers, from beginners to experienced professionals. Hereâ€™s why it might be a good fit for you:

1. **For beginners:** It provides a solid foundation with best practices and common solutions, helping you learn industry-standard approaches to React Native development.

2. **For experienced developers:** It offers a well-structured, production-ready setup that can save you time and effort in project initialization and configuration.

3. **For teams:** It ensures consistency across projects and team members, making it easier to onboard new developers and maintain code quality.

4. **For explorers:** Even if you prefer not to use starter kits, this project can serve as a valuable reference. You can explore the codebase, documentation, and architectural decisions to gain insights and potentially adopt specific solutions for your own projects.

5. **For learners:** The starter kit incorporates up-to-date libraries and patterns, offering an opportunity to familiarize yourself with current best practices in the React Native ecosystem.

6. **For AI-assisted development:** This starter kit works well with AI coding tools. It provides a solid structure and best practices that can guide AI-generated code. This helps ensure that AI assistance leads to high-quality, maintainable code that fits well within your project.

Remember, you donâ€™t have to use the entire starter kit as-is. Feel free to cherry-pick ideas, configurations, or code snippets that align with your project needs. Whether youâ€™re building a new app from scratch or looking to improve your existing development process, this starter kit can provide valuable insights and practical solutions.

## ğŸ˜‰ Why Expo and not React Native CLI?

[Section titled â€œğŸ˜‰ Why Expo and not React Native CLI?â€](#-why-expo-and-not-react-native-cli)

We have been using Expo as our main framework since the introduction of [Continuous Native Generation (CNG)](https://docs.expo.dev/workflow/continuous-native-generation/) concept and we are happy with the experience.

I think this question is not valid anymore specially after the last React conference when the core react native team recommended using Expo for new projects.

> â€œAs of today, the only recommended community framework for React Native is Expo. Folks at Expo have been investing in the React Native ecosystem since the early days of React Native and as of today, we believe the developer experience offered by Expo is best in class.â€ React native core team

Still hesitating? Check out this [article](https://reactnative.dev/blog/2024/06/25/use-a-framework-to-build-react-native-apps) or this [video](https://www.youtube.com/watch?v=lifGTznLBcw), maybe this one [video](https://www.youtube.com/watch?v=ek_IdGC0G80) too.

## ğŸ§‘â€ğŸ’» Stay up to date

[Section titled â€œğŸ§‘â€ğŸ’» Stay up to dateâ€](#-stay-up-to-date)

We are committed to continually improving our starter kit and providing the best possible resources for building React Native apps. To that end, we regularly add new features and fix any bugs that are discovered.

If you want to stay up to date with the latest developments in our starter kit, you can either watch the repository or hit the â€œstarâ€ button. This will allow you to receive notifications whenever new updates are available.

We value the feedback and contributions of our users, and we encourage you to let us know if you have any suggestions for improving our starter kit. We are always looking for ways to make it even more effective and useful for our community. So, please do not hesitate to reach out and share your thoughts with us.

<!-- add a gif image here  -->

## ğŸ’ Libraries used

[Section titled â€œğŸ’ Libraries usedâ€](#-libraries-used)

* [Expo](https://docs.expo.io/)
* [Expo Router](https://docs.expo.dev/router/introduction/)
* [Nativewind](https://www.nativewind.dev/v4/overview)
* [Flash list](https://github.com/Shopify/flash-list)
* [React Query](https://tanstack.com/query/v4)
* [Axios](https://axios-http.com/docs/intro)
* [React Hook Form](https://react-hook-form.com/)
* [i18next](https://www.i18next.com/)
* [zustand](https://github.com/pmndrs/zustand)
* [React Native MMKV](https://github.com/mrousavy/react-native-mmkv)
* [React Native Gesture Handler](https://docs.swmansion.com/react-native-gesture-handler/docs/)
* [React Native Reanimated](https://docs.swmansion.com/react-native-reanimated/docs/)
* [React Native Svg](https://github.com/software-mansion/react-native-svg)
* [React Error Boundaries](https://github.com/bvaughn/react-error-boundary)
* [Expo Image](https://docs.expo.dev/versions/unversioned/sdk/image/)
* [React Native Keyboard Controller](https://github.com/kirillzyusko/react-native-keyboard-controller)
* [Moti](https://moti.fyi/)
* [React Native Safe Area Context](https://github.com/th3rdwave/react-native-safe-area-context)
* [React Native Screens](https://github.com/software-mansion/react-native-screens)
* [Tailwind Variants](https://www.tailwind-variants.org/)
* [Zod](https://zod.dev/)

## Contributors

[Section titled â€œContributorsâ€](#contributors)

This starter is maintained by [Obytes mobile tribe team](https://www.obytes.com/team) and we welcome new contributors to join us in improving it. If you are interested in getting involved in the project, please donâ€™t hesitate to open an issue or submit a pull request.

In addition to maintaining this starter kit, we are also available to work on custom projects and help you build your dream app. If you are looking for experienced and reliable developers to bring your app vision to life, please visit our website at [obytes.com/contact](https://www.obytes.com/contact) to get in touch with us. We would be happy to discuss your project in more detail and explore how we can help you achieve your goals.

## â“ FAQ

[Section titled â€œâ“ FAQâ€](#-faq)

If you have any questions about the starter and want answers, please check out the [Discussions](https://github.com/obytes/react-native-template-obytes/discussions) page.

# Sentry Setup

> How to setup Sentry in your app.

Sentry is one of the most popular solution for error reporting in the javascript ecosystem and has a great integration with Expo, we have been using it for a while and it has been working very well.

The starter kit did not come with Sentry pre-configured, but itâ€™s very easy to setup and this guide will walk you through the process.

## Install and configure Sentry

[Section titled â€œInstall and configure Sentryâ€](#install-and-configure-sentry)

1. Create a new [Sentry account](https://sentry.io/signup/) if you donâ€™t have one already. Once logged in, create a new project for your React Native app.

2. During project creation, pay close attention to and note down the following important details:

   * Organization slug

   * Project name

   * DSN

     we will use those details next to configure the Sentry SDK in your app.

3. Now you need also to generate a new Auth Token so you can use it to upload source maps to Sentry. To generate a new Auth Token you need to go to Developer [Settings > Auth Tokens](https://sentry.io/settings/auth-tokens/) and create a new token.

   * Copy and securely store the generated token. Youâ€™ll need this for configuring source map uploads.

4. At this point, you should have the following environment variables that need to be added to your `.env` files:

   ```bash
   SENTRY_ORG=your_sentry_organization_slug
   SENTRY_PROJECT=your_sentry_project_name
   SENTRY_DSN=your_sentry_dsn
   ```

   Note

   You can use the same Sentry configuration for all app variants (development, staging, production) as Sentry allows you to filter errors by app ID or package name in the dashboard. This simplifies setup and management while still providing the ability to distinguish between different environments.

   Itâ€™s crucial to add these variables to `env.js` for validation. `SENTRY_ORG` and `SENTRY_PROJECT` should be added as build-time variables, while `SENTRY_DSN` should be added as a client variable.

   Update your `env.js` file as follows:

   env.js

   ```js
   // ... existing imports and configurations


   const client = z.object({
     // ... other client env vars
     SENTRY_DSN: z.string().min(1, 'SENTRY_DSN is required'),
   });


   const buildTime = z.object({
     // ... other build-time env vars
     SENTRY_ORG: z.string().min(1, 'SENTRY_ORG is required'),
     SENTRY_PROJECT: z.string().min(1, 'SENTRY_PROJECT is required'),
   });


   const _clientEnv = {
     // ... other client env vars
     SENTRY_DSN: process.env.SENTRY_DSN,
   };


   const _buildTimeEnv = {
     // ... other build-time env vars
     SENTRY_ORG: process.env.SENTRY_ORG,
     SENTRY_PROJECT: process.env.SENTRY_PROJECT,
   };


   // ... rest of the file
   ```

   Note

   The `SENTRY_AUTH_TOKEN` should not be added to the `.env` file as itâ€™s sensitive information that shouldnâ€™t be exposed or pushed to version control. Instead, add it as an EAS secret using the [Expo dashboard](https://expo.dev/accounts/%5Baccount%5D/projects/%5Bproject%5D/secrets) or the EAS CLI:

   ```bash
   eas secret:create --scope your-project-name --name SENTRY_AUTH_TOKEN --value your-token-value --type string
   ```

   This ensures that your Sentry authentication token remains secure while still being accessible during the build process.

5. Now you can install the Sentry SDK in your project.

   ```bash
   npx expo install @sentry/react-native
   ```

6. Add Sentry plugin config to your `app.config.ts` file.

   app.config.ts

   ```tsx
   // rest of the file


   import { ClientEnv, Env } from './env';


   export default ({ config }: ConfigContext): ExpoConfig => ({
     ...config,
     // rest of the config


     plugins: [
       // rest of the plugins
       [
         '@sentry/react-native/expo',
         {
           url: 'https://sentry.io/',
           organization: Env.SENTRY_ORG,
           project: Env.SENTRY_PROJECT,
           note: 'Ensure you set the SENTRY_AUTH_TOKEN as an environment variable to authenticate with Sentry. Do not add it to the .env file. Instead, add it as an EAS secret or as an environment variable in your CI/CD pipeline for security.',
           // If you are using a self-hosted instance, update the value of the url property
           // to point towards your self-hosted instance. For example, https://self-hosted.example.com/.
         },
       ],
     ],
   });
   ```

7. Update your metro config to inject debug ID intro your source maps

   metro.config.js

   ```js
   /* eslint-env node */
   // this replaces `const { getDefaultConfig } = require('expo/metro-config');`
   const { getSentryExpoConfig } = require('@sentry/react-native/metro');
   const { withNativeWind } = require('nativewind/metro');


   const config = getSentryExpoConfig(__dirname);


   module.exports = withNativeWind(config, { input: './global.css' });
   ```

8. Now you are ready to initialize Sentry in your app. Create a new file `src/lib/sentry.ts` and add the following code:

   src/lib/sentry.ts

   ```tsx
   import { Env } from '@env';
   import * as Sentry from '@sentry/react-native';
   import { useNavigationContainerRef } from 'expo-router';
   import { useEffect } from 'react';


   const navigationIntegration = Sentry.reactNavigationIntegration({
     enableTimeToInitialDisplay: true,
   });


   export const initSentry = () => {
     if (!__DEV__) {
       Sentry.init({
         dsn: Env.SENTRY_DSN,
         integrations: [navigationIntegration],
       });
     }
   };


   export const useSentryNavigationConfig = () => {
     const navigationRef = useNavigationContainerRef();


     useEffect(() => {
       if (navigationRef && !__DEV__) {
         navigationIntegration.registerNavigationContainer(navigationRef);
       }
     }, [navigationRef]);
   };
   ```

   Then, initialize Sentry and configure it with navigation in your `src/app/_layout.tsx` file:

   src/app/\_layout.tsx

   ```tsx
   import { initSentry, useSentryNavigationConfig } from '@/lib/sentry';
   import * as Sentry from '@sentry/react-native';


   initSentry();


   function RootLayout() {
     useSentryNavigationConfig();


     return (
       <Providers>
         <Stack>
           <Stack.Screen name="(app)" options={{ headerShown: false }} />
           <Stack.Screen name="onboarding" options={{ headerShown: false }} />
           ...
         </Stack>
       </Providers>
     );
   }


   // Wrap your app with Sentry
   export default Sentry.wrap(RootLayout);
   ```

   This setup will enable Sentry error tracking and performance monitoring in your app.

9. One last thing is to add Apple privacy manifest to prevent any issues with Apple. Create a new file `apple-privacy-manifest.json` and add the following code:

   apple-privacy-manifest.json

   ```json
   {
     "NSPrivacyCollectedDataTypes": [
       {
         "NSPrivacyCollectedDataType": "NSPrivacyCollectedDataTypeCrashData",
         "NSPrivacyCollectedDataTypeLinked": false,
         "NSPrivacyCollectedDataTypeTracking": false,
         "NSPrivacyCollectedDataTypePurposes": [
           "NSPrivacyCollectedDataTypePurposeAppFunctionality"
         ]
       },
       {
         "NSPrivacyCollectedDataType": "NSPrivacyCollectedDataTypePerformanceData",
         "NSPrivacyCollectedDataTypeLinked": false,
         "NSPrivacyCollectedDataTypeTracking": false,
         "NSPrivacyCollectedDataTypePurposes": [
           "NSPrivacyCollectedDataTypePurposeAppFunctionality"
         ]
       },
       {
         "NSPrivacyCollectedDataType": "NSPrivacyCollectedDataTypeOtherDiagnosticData",
         "NSPrivacyCollectedDataTypeLinked": false,
         "NSPrivacyCollectedDataTypeTracking": false,
         "NSPrivacyCollectedDataTypePurposes": [
           "NSPrivacyCollectedDataTypePurposeAppFunctionality"
         ]
       }
     ],
     "NSPrivacyAccessedAPITypes": [
       {
         "NSPrivacyAccessedAPIType": "NSPrivacyAccessedAPICategoryUserDefaults",
         "NSPrivacyAccessedAPITypeReasons": ["CA92.1"]
       },
       {
         "NSPrivacyAccessedAPIType": "NSPrivacyAccessedAPICategorySystemBootTime",
         "NSPrivacyAccessedAPITypeReasons": ["35F9.1"]
       },
       {
         "NSPrivacyAccessedAPIType": "NSPrivacyAccessedAPICategoryFileTimestamp",
         "NSPrivacyAccessedAPITypeReasons": ["C617.1"]
       }
     ]
   }
   ```

   Then add it to your `app.config.ts`

   app.config.ts

   ```ts
   import applePrivacyManifest from './apple-privacy-manifest.json';
   export default ({ config }: ConfigContext): ExpoConfig => ({
     ...config,
     // rest of the config
     ios: {
       // rest of ios config
       privacyManifests: applePrivacyManifest,
     },
   });
   ```

   Read more about [Apple Privacy Manifest and sentry](https://docs.sentry.io/platforms/react-native/data-management/apple-privacy-manifest/)

10. Now you are ready to test Sentry integration. Follow these steps to ensure errors are being reported correctly:

    1. Run the prebuild command for your project.
    2. Launch the app in a simulator or on a physical device.
    3. Use the following code snippet to add error-triggering buttons to your app:

    ```tsx
    import React from 'react';
    import { View, Button } from 'react-native';
    import * as Sentry from '@sentry/react-native';


    const SentryTestComponent = () => {
      const throwJSError = () => {
        throw new Error('Test JavaScript Error for Sentry');
      };


      const triggerNativeError = () => {
        Sentry.nativeCrash();
      };


      return (
        <View>
          <Button title="Trigger JS Error" onPress={throwJSError} />
          <Button title="Trigger Native Error" onPress={triggerNativeError} />
        </View>
      );
    };


    export default SentryTestComponent;
    ```

    4. Implement this component in your app and interact with the buttons.
    5. Check your Sentry dashboard to verify that the errors are being reported correctly (make sure to wait a little bit for the errors to appear).

    Remember to remove or disable these test buttons before releasing your app to production.

## More Resources

[Section titled â€œMore Resourcesâ€](#more-resources)

* [Expo Sentry](https://docs.expo.dev/guides/using-sentry/)
* [Sentry Documentation](https://docs.sentry.io/platforms/react-native/manual-setup/expo/)

# What people say about the starter

> What people say about the starter

This is a list of reviews from people who have used the starter kit.

Please feel free to add your in the comments section ğŸ‘‡

# Stay Up-to-Date with React Native

> Stay up-to-date with React Native news.

Make sure to check out the links below to stay up-to-date with React Native news.

Note

We are in favor of reducing the number of news sources you use to avoid feeling overwhelmed. Therefore, we have only included resources that we think are essential and deserve your attention.

## Websites

[Section titled â€œWebsitesâ€](#websites)

* [React Native Documentation](https://reactnative.dev/)
* [React Native Directory](https://reactnative.directory/)
* [React Native Reddit Channel](https://www.reddit.com/r/reactnative/)

## Blogs

[Section titled â€œBlogsâ€](#blogs)

* [Expo blog](https://blog.expo.dev/)
* [React Native Dev Blog](https://reactnative.dev/blog)
* [TkDodoâ€™s blog](https://tkdodo.eu/blog/)
* [Developer way](https://www.developerway.com/)
* [Bam React Native blog](https://www.bam.tech/blog/react-native)

## Newsletters

[Section titled â€œNewslettersâ€](#newsletters)

* [This week in react](https://thisweekinreact.com/)
* [The React Native Newsletter](https://reactnativenewsletter.com/)

## Twitter accounts

[Section titled â€œTwitter accountsâ€](#twitter-accounts)

* [Evan Bacon](https://twitter.com/Baconbrix)
* [React Native](https://twitter.com/reactnative)
* [Expo](https://twitter.com/expo)
* [Sebastien Lorber](https://twitter.com/sebastienlorber)

## Open source projects

[Section titled â€œOpen source projectsâ€](#open-source-projects)

A list of open-source projects and production-ready apps that you can use to learn and get inspired from.

* [showtime-frontend](https://github.com/showtime-xyz/showtime-frontend)
* [xLog-mobile](https://github.com/Crossbell-Box/xLog-mobile)
* [CommE2E](https://github.com/CommE2E/comm)
* [Expensify](https://github.com/Expensify/App)

# End-to-End Testing

> How to write end-to-end tests using Maestro

Writing end-to-end tests is one of the best ways to ensure that your app is working as expected and simulate exactly how a user would interact with it. However, running those tests can be challenging and time-consuming due to their nature and the need to run them on a device or emulator.

The good news is that we have included [Maestro](https://www.mobile.dev/) the easiest way to run end-to-end tests yet very powerful and come up with a lot of features that will make your life easier.

One of Maestroâ€™s best features is its user-friendly test writing capability. Itâ€™s incredibly simple to write tests using the app, making it accessible to PMs, QAs, and even designers.

Tip

Watch this talk by the amazing Henry Moulton for more details about Maestro and how it can help you write better tests: [Henry Moulton â€“ React Native end-to-end testing with Maestro | App.js Conf 2023](https://www.youtube.com/watch?v=uoCzBdFCoqc)

## Installing Maestro

[Section titled â€œInstalling Maestroâ€](#installing-maestro)

To install Maestro, run the following :

```bash
# a simple npm script that runs the following command:  curl -Ls 'https://get.maestro.mobile.dev' | bash
pnpm install-maestro
```

## Writing tests

[Section titled â€œWriting testsâ€](#writing-tests)

Go to the `maestro` directory and write your tests. Here is a quick test we wrote for log in screen using Maestro:

Read more about how to write end-to-end test with Maestro [here](https://maestro.mobile.dev/)

.maestro/auth/login-with-validation.yaml

```yaml
appId: ${APP_ID}
env:
  Name: 'User'
  EMAIL: 'user@test.com'
  PASSWORD: 'password'
---
- launchApp
- runFlow:
    when:
      visible: 'Atlas Starter'
    file: ../utils/onboarding.yaml
- assertVisible: 'Sign In'
- assertVisible:
    id: 'login-button'
- tapOn:
    id: 'login-button'
- assertVisible: 'Email is required'
- assertVisible: 'Password is required'
- tapOn:
    id: 'name'
- inputText: ${Name}
- runFlow: ../utils/hide-keyboard.yaml
- tapOn:
    id: 'email-input'
- inputText: 'email'
- assertVisible: 'Invalid email format'
- inputText: ${EMAIL}
- runFlow: ../utils/hide-keyboard.yaml
- tapOn:
    id: 'password-input'
- inputText: ${PASSWORD}
- runFlow: ../utils/hide-keyboard.yaml
- tapOn:
    id: 'login-button'
- assertVisible: 'Feed'
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

To run the tests, execute the following command:

```bash
pnpm e2e-test
```

This will run the tests on the local emulator and here is a recording of the test from maestro dashboard:

[](https://github.com/obytes/react-native-template-obytes/assets/11137944/3b45de00-a369-436a-8faf-6ea1edbb44c3)

## Running tests on CI

[Section titled â€œRunning tests on CIâ€](#running-tests-on-ci)

Running tests on CI is very important to ensure that your code doesnâ€™t break when you push it to GitHub. However, running end-to-end tests is quite expensive and time-consuming. To test your app on CI, we need to first build the app, set up the emulator, and then run the tests. This process can consume a significant amount of time and resources.

For this reason, we do not recommend running end-to-end tests on every pull request pushed to GitHub. Instead, we recommend running them for pull requests that contain `test-android` labels so that we can trigger the tests manually by adding the correct label whenever you feel the PR is ready to be tested.

The starter comes with a bunch of GitHub actions that will help you run the tests on CI.

> for now we only support running tests on Android, we are working on adding support for iOS.

* `e2e-android.yml` - Triggered when a PR is labeled with `android-test-github` or run manually from the actions tab in GitHub. This action will generate a staging build for the app, set up the emulator, and run the tests using Maestro.

* `e2e-android-maestro.yml` - Triggered when a PR is labeled with `android-test-maestro-cloud` or run manually from the actions tab in GitHub. This action will run the tests using Maestro Cloud. You will need to add your Maestro Cloud token to the secrets in GitHub.

* `e2e-android-eas-build.yml` - Accepts a EAS APK URL and runs the tests. This action is triggered manually from the actions tab in GitHub.

# Testing Overview

> What to test and how to test it.

Testing is an essential part of any software development process. It helps ensure that your code is working as expected and that you donâ€™t introduce any bugs into your codebase. As we believe in the importance of testing, we have made it easy to write your tests with the starter template. We include the [Jest](https://jestjs.io/) testing framework and the [React Native Testing Library](https://callstack.github.io/react-native-testing-library/) for unit tests, along with mocks for most libraries. We also use [Maestro](https://maestro.mobile.dev/) for end-to-end tests.

## Testing approaches

[Section titled â€œTesting approachesâ€](#testing-approaches)

Itâ€™s clear that testing is important, but what should you test? Apparently, and especially for front-end apps (including mobile apps), there is no clear answer. Should I aim for 100% code coverage? Should I test every component?

The answer is it depends. It depends on your app, your team, and your goals. We believe that testing is a trade-off between the time you spend writing tests and the confidence you get from them. You should aim for a good balance between the two.

Aiming for 100% test coverage is not always a good idea and doesnâ€™t always make sense. Same with testing views and components that only render a UI. Instead, you should focus on the following:

* **Business logic**: Test component and function utilities that contain business logic. Form validation, data manipulation and calculations, etc.

* **Complex components**: Test components that contain complex logic. For example, components that contain a lot of conditional rendering, or components that contain a lot of state management logic.

Focus on the above and write unit tests for them. This will help you get the most out of your tests and will assist you in finding bugs early on.

To ensure that your app is functioning as expected, we recommend writing end-to-end tests, as they provide the highest level of confidence and help you test the app as a whole similar to how your users will use it.

# Unit Tests

> How to write unit tests using Jest and React Native Testing Library

As we mention in the overview page of the testing section, we include the [Jest](https://jestjs.io/) testing framework and the [React Native Testing Library](https://callstack.github.io/react-native-testing-library/) for unit tests, along with mocks for most libraries.

The following guide is not a tutorial on how to write tests using React Native Testing Library and Jest, but rather a guide on how to write tests with this starter and some best practices to follow. If you are not familiar with testing, we recommend reading the [official documentation](https://jestjs.io/docs/en/getting-started) of Jest and [React Native Testing Library](https://callstack.github.io/react-native-testing-library/) to get familiar with them.

Also worth mentioning that we should aim to test the following:

* **Business logic**: Test component and function utilities that contain business logic. Form validation, data manipulation and calculations, etc.

* **Complex components**: Test components that contain complex logic. For example, components that contain a lot of conditional rendering, or components that contain a lot of state management logic.

## Writing tests

[Section titled â€œWriting testsâ€](#writing-tests)

Letâ€™s start by writing a simple test for our login screen. We will test the following login form component:

./src/components/login-form.tsx

```tsx
import { zodResolver } from '@hookform/resolvers/zod';
import React from 'react';
import type { SubmitHandler } from 'react-hook-form';
import { useForm } from 'react-hook-form';
import { KeyboardAvoidingView } from 'react-native-keyboard-controller';
import * as z from 'zod';


import { Button, ControlledInput, Text, View } from '@/components/ui';


const schema = z.object({
  name: z.string().optional(),
  email: z
    .string({
      required_error: 'Email is required',
    })
    .email('Invalid email format'),
  password: z
    .string({
      required_error: 'Password is required',
    })
    .min(6, 'Password must be at least 6 characters'),
});


export type FormType = z.infer<typeof schema>;


export type LoginFormProps = {
  onSubmit?: SubmitHandler<FormType>;
};


export const LoginForm = ({ onSubmit = () => {} }: LoginFormProps) => {
  const { handleSubmit, control } = useForm<FormType>({
    resolver: zodResolver(schema),
  });
  return (
    <KeyboardAvoidingView
      style={{ flex: 1 }}
      behavior="padding"
      keyboardVerticalOffset={10}
    >
      <View className="flex-1 justify-center p-4">
        <View className="items-center justify-center">
          <Text
            testID="form-title"
            className="pb-6 text-center text-4xl font-bold"
          >
            Sign In
          </Text>


          <Text className="mb-6 max-w-xs text-center text-gray-500">
            Welcome! ğŸ‘‹ This is a demo login screen! Feel free to use any email
            and password to sign in and try it out.
          </Text>
        </View>


        <ControlledInput
          testID="name"
          control={control}
          name="name"
          label="Name"
        />


        <ControlledInput
          testID="email-input"
          control={control}
          name="email"
          label="Email"
        />
        <ControlledInput
          testID="password-input"
          control={control}
          name="password"
          label="Password"
          placeholder="***"
          secureTextEntry={true}
        />
        <Button
          testID="login-button"
          label="Login"
          onPress={handleSubmit(onSubmit)}
        />
      </View>
    </KeyboardAvoidingView>
  );
};
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

Tip

To make it easier to write tests, we are separating the form from any other logic related to API calls, navigation, etc. This way, we can test the form logic without having to worry about other things.

As you may have noticed, writing code with the intention of writing tests for it will assist us in producing cleaner code.

Now, letâ€™s write a test for the login form component. We will test the following:

* The form renders correctly.
* Show the correct error messages on invalid or missing data.
* Submit the form with valid data and make sure that the `onSubmit` function is called with the correct data.

First, letâ€™s create a new file called `login-form.test.tsx` in the `src/screens/login` directory. Then, add the following code to it:

./src/components/login-form.test.tsx

```tsx
import React from 'react';


import { cleanup, screen, setup, waitFor } from '@/lib/test-utils';


import type { LoginFormProps } from './login-form';
import { LoginForm } from './login-form';


afterEach(cleanup);


const onSubmitMock: jest.Mock<LoginFormProps['onSubmit']> = jest.fn();


describe('LoginForm Form ', () => {
  it('renders correctly', async () => {
    setup(<LoginForm />);
    expect(await screen.findByTestId('form-title')).toBeOnTheScreen();
  });


  it('should display required error when values are empty', async () => {
    const { user } = setup(<LoginForm />);


    const button = screen.getByTestId('login-button');
    expect(screen.queryByText(/Email is required/i)).not.toBeOnTheScreen();
    await user.press(button);
    expect(await screen.findByText(/Email is required/i)).toBeOnTheScreen();
    expect(screen.getByText(/Password is required/i)).toBeOnTheScreen();
  });


  it('should display matching error when email is invalid', async () => {
    const { user } = setup(<LoginForm />);


    const button = screen.getByTestId('login-button');
    const emailInput = screen.getByTestId('email-input');
    const passwordInput = screen.getByTestId('password-input');


    await user.type(emailInput, 'yyyyy');
    await user.type(passwordInput, 'test');
    await user.press(button);


    expect(await screen.findByText(/Invalid Email Format/i)).toBeOnTheScreen();
    expect(screen.queryByText(/Email is required/i)).not.toBeOnTheScreen();
  });


  it('Should call LoginForm with correct values when values are valid', async () => {
    const { user } = setup(<LoginForm onSubmit={onSubmitMock} />);


    const button = screen.getByTestId('login-button');
    const emailInput = screen.getByTestId('email-input');
    const passwordInput = screen.getByTestId('password-input');


    await user.type(emailInput, 'youssef@gmail.com');
    await user.type(passwordInput, 'password');
    await user.press(button);
    await waitFor(() => {
      expect(onSubmitMock).toHaveBeenCalledTimes(1);
    });
    // expect.objectContaining({}) because we don't want to test the target event we are receiving from the onSubmit function
    expect(onSubmitMock).toHaveBeenCalledWith(
      {
        email: 'youssef@gmail.com',
        password: 'password',
      },
      expect.objectContaining({})
    );
  });
});
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

As you may notice from the code, we are importing a bunch of things from the `@/lib/test-utils` directory. This is a simple file that exports everything from the `@testing-library/react-native` library and overrides the `render` function to wrap the component with the providers we need. This way, we donâ€™t have to import the providers in every test file.

Tip

You can update this file to add any other providers you need to wrap your components with as well as any other utility functions you need to use in your tests.

src/lib/test-utils.tsx

```tsx
import '@shopify/flash-list/jestSetup';


import { BottomSheetModalProvider } from '@gorhom/bottom-sheet';
import { NavigationContainer } from '@react-navigation/native';
import type { RenderOptions } from '@testing-library/react-native';
import { render, userEvent } from '@testing-library/react-native';
import type { ReactElement } from 'react';
import React from 'react';


const createAppWrapper = () => {
  return ({ children }: { children: React.ReactNode }) => (
    <BottomSheetModalProvider>
      <NavigationContainer>{children}</NavigationContainer>
    </BottomSheetModalProvider>
  );
};


const customRender = (
  ui: ReactElement,
  options?: Omit<RenderOptions, 'wrapper'>
) => {
  const Wrapper = createAppWrapper(); // make sure we have a new wrapper for each render
  return render(ui, { wrapper: Wrapper, ...options });
};


// use this if you want to test user events
export const setup = (
  ui: ReactElement,
  options?: Omit<RenderOptions, 'wrapper'>
) => {
  const Wrapper = createAppWrapper();
  return {
    user: userEvent.setup(),
    ...render(ui, { wrapper: Wrapper, ...options }),
  };
};


export * from '@testing-library/react-native';
export { customRender as render };
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

use `setup` function in case you need to test interactions with the component. It returns a user (userEvent) object that you can use to interact with the component.

Now that we have our test file ready, letâ€™s run it and see what happens. To run the test, run the following command:

```bash
pnpm  test
pnpm test:watch # To run the tests in watch mode
```

## Tests on CI with GitHub actions

[Section titled â€œTests on CI with GitHub actionsâ€](#tests-on-ci-with-github-actions)

Itâ€™s important to run tests on CI in addition to local testing. This ensures that our code doesnâ€™t break when we push it to Github. We have added a GitHub action that runs tests for every push to the main branch or new pull request. It reports the results to GitHub through annotations and provides a summary of the tests along with coverage.

Here is an example of the output of the GitHub action:

![GitHub action output](https://github.com/obytes/react-native-template-obytes/assets/11137944/081896b2-bf74-490b-9ad5-da8e2bbc5c88)

Tip

Aiming for 100% test coverage is not always a good idea and doesnâ€™t always make sense. Same with testing views and components that only render a UI

## More tests

[Section titled â€œMore testsâ€](#more-tests)

For more complex logic and components, we recommend taking a look at this amazing project which provides a lot of examples and best practices for testing React Native apps using React Native Testing Library and Jest:

[âš¡ï¸ React Native Testing](https://github.com/vanGalilea/react-native-testing/)

[React Native Testing Library Cookbook](https://callstack.github.io/react-native-testing-library/cookbook/index)

# UI Components

> List of all UI components and how to use them.

The starter comes with a set of basic components and a simple design system based on Nativewind to help you get started and save you time.

All those components can be found in the `src/components/ui` folder. Our philosophy is to keep the components as simple as possible and to avoid adding too much logic to them. This way, they are easier to reuse and customize.

Based on your needs, you can either use them as they are or customize them to fit your needs. You can also create new ones based on the same approach.

* ui ## core ui and theme configuration

  * button.tsx

  * checkbox.tsx

  * colors.js

  * focus-aware-status-bar.tsx

  * icons/

    * â€¦

  * image.tsx

  * index.tsx

  * input.tsx

  * list.tsx

  * modal.tsx

  * progress-bar.tsx

  * select.tsx

  * text.tsx

  * utils.tsx

Tip

To save time when creating new components or screens, we can simply start typing `comp` and press Enter to generate a new component with the correct structure.

![Create component](https://github.com/obytes/react-native-template-obytes/assets/11137944/ca84555f-12b7-4048-98b8-3c8391bd9918)

## List

[Section titled â€œListâ€](#list)

The `List` component references the FlashList component from the `@shopify/flash-list` package.

src/components/ui/list.tsx

```tsx
import { FlashList as NFlashList } from '@shopify/flash-list';
import React from 'react';
import { ActivityIndicator, View } from 'react-native';
import Svg, { Circle, Path } from 'react-native-svg';


import { Text } from './text';
type Props = {
  isLoading: boolean;
};


export const List = NFlashList;


export const EmptyList = React.memo(({ isLoading }: Props) => {
  return (
    <View className="min-h-[400px] flex-1 items-center justify-center">
      {!isLoading ? (
        <View>
          <NoData />
          <Text className="pt-4 text-center">Sorry! No data found</Text>
        </View>
      ) : (
        <ActivityIndicator />
      )}
    </View>
  );
});


export const NoData = () => (
  <Svg width={200} height={200} viewBox="0 0 647.636 632.174">
    <Path
      d="M411.146 142.174h-174.51a15.018 15.018 0 0 0-15 15v387.85l-2 .61-42.81 13.11a8.007 8.007 0 0 1-9.99-5.31l-127.34-415.95a8.003 8.003 0 0 1 5.31-9.99l65.97-20.2 191.25-58.54 65.97-20.2a7.99 7.99 0 0 1 9.99 5.3l32.55 106.32Z"
      fill="#f2f2f2"
    />
    <Path
      d="m449.226 140.174-39.23-128.14a16.994 16.994 0 0 0-21.23-11.28l-92.75 28.39-191.24 58.55-92.75 28.4a17.015 17.015 0 0 0-11.28 21.23l134.08 437.93a17.027 17.027 0 0 0 16.26 12.03 16.79 16.79 0 0 0 4.97-.75l63.58-19.46 2-.62v-2.09l-2 .61-64.17 19.65a15.015 15.015 0 0 1-18.73-9.95L2.666 136.734a14.98 14.98 0 0 1 9.95-18.73l92.75-28.4 191.24-58.54 92.75-28.4a15.156 15.156 0 0 1 4.41-.66 15.015 15.015 0 0 1 14.32 10.61l39.05 127.56.62 2h2.08Z"
      fill="#3f3d56"
    />
    <Path
      d="M122.68 127.82a9.016 9.016 0 0 1-8.61-6.366l-12.88-42.072a8.999 8.999 0 0 1 5.97-11.24L283.1 14.278a9.009 9.009 0 0 1 11.24 5.971l12.88 42.072a9.01 9.01 0 0 1-5.97 11.241l-175.94 53.864a8.976 8.976 0 0 1-2.63.395Z"
      fill="#7eb55a"
    />
    <Circle cx={190.154} cy={24.955} r={20} fill="#7eb55a" />
    <Circle cx={190.154} cy={24.955} r={12.665} fill="#fff" />
    <Path
      d="M602.636 582.174h-338a8.51 8.51 0 0 1-8.5-8.5v-405a8.51 8.51 0 0 1 8.5-8.5h338a8.51 8.51 0 0 1 8.5 8.5v405a8.51 8.51 0 0 1-8.5 8.5Z"
      fill="#e6e6e6"
    />
    <Path
      d="M447.136 140.174h-210.5a17.024 17.024 0 0 0-17 17v407.8l2-.61v-407.19a15.018 15.018 0 0 1 15-15h211.12Zm183.5 0h-394a17.024 17.024 0 0 0-17 17v458a17.024 17.024 0 0 0 17 17h394a17.024 17.024 0 0 0 17-17v-458a17.024 17.024 0 0 0-17-17Zm15 475a15.018 15.018 0 0 1-15 15h-394a15.018 15.018 0 0 1-15-15v-458a15.018 15.018 0 0 1 15-15h394a15.018 15.018 0 0 1 15 15Z"
      fill="#3f3d56"
    />
    <Path
      d="M525.636 184.174h-184a9.01 9.01 0 0 1-9-9v-44a9.01 9.01 0 0 1 9-9h184a9.01 9.01 0 0 1 9 9v44a9.01 9.01 0 0 1-9 9Z"
      fill="#7eb55a"
    />
    <Circle cx={433.636} cy={105.174} r={20} fill="#7eb55a" />
    <Circle cx={433.636} cy={105.174} r={12.182} fill="#fff" />
  </Svg>
);
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

**Props**

* All `@shopify/flash-list` Props are supported

We also provide an `EmptyList` component that you can use to display a message when the list is empty. Feel free to customize it to fit your needs.

**Use Case**

```tsx
import * as React from 'react';
import { List, EmptyList, Text } from '@/components/ui';


const MyComponent = () => {
  return (
    <List
      data={['Item 1', 'Item 2']}
      renderItem={({ item }) => <Text>{item}</Text>}
      ListEmptyComponent={<EmptyList message="No items" />}
    />
  );
};
```

## Image

[Section titled â€œImageâ€](#image)

For the `Image` component, we use the `expo-image` library to provide a fast and performant image component. The `Image` component is a wrapper around the `Image` component from `expo-image` package with additional styling provided by `nativewind`. The `withUniwind` function from `uniwind` is used to apply styling and, in this way, the `className` property is applied to the `style` property of the `Image` component.

src/components/ui/image.tsx

```tsx
import type { ImageProps } from 'expo-image';
import { Image as NImage } from 'expo-image';
import * as React from 'react';
import { withUniwind } from 'uniwind';


export type ImgProps = ImageProps & {
  className?: string;
};


withUniwind(NImage);


export const Image = ({
  style,
  className,
  placeholder = 'L6PZfSi_.AyE_3t7t7R**0o#DgR4',
  ...props
}: ImgProps) => {
  return (
    <NImage
      className={className}
      placeholder={placeholder}
      style={style}
      {...props}
    />
  );
};


export const preloadImages = (sources: string[]) => {
  NImage.prefetch(sources);
};
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

**Props**

* All `expo-image` Props are supported
* `className` - Tailwind CSS class names

**Use Case**

```tsx
import * as React from 'react';
import { Image } from '@/components/ui';


const MyComponent = () => {
  return (
    <Image
      className="h-32 w-32"
      source={{
        uri: 'https://images.unsplash.com/photo-1524758631624-e2822e304c36',
      }}
    />
  );
};
```

## Text

[Section titled â€œTextâ€](#text)

With this custom Text component, you can use the translation key as the `tx` prop, and it will automatically translate the text based on the current locale, as well as support right-to-left (RTL) languages based on the selected locale.

src/components/ui/text.tsx

```tsx
import React from 'react';
import type { TextProps, TextStyle } from 'react-native';
import { I18nManager, StyleSheet, Text as NNText } from 'react-native';
import { twMerge } from 'tailwind-merge';


import type { TxKeyPath } from '@/lib/i18n';
import { translate } from '@/lib/i18n';


interface Props extends TextProps {
  className?: string;
  tx?: TxKeyPath;
}


export const Text = ({
  className = '',
  style,
  tx,
  children,
  ...props
}: Props) => {
  const textStyle = React.useMemo(
    () =>
      twMerge(
        'text-base text-black  dark:text-white  font-inter font-normal',
        className
      ),
    [className]
  );


  const nStyle = React.useMemo(
    () =>
      StyleSheet.flatten([
        {
          writingDirection: I18nManager.isRTL ? 'rtl' : 'ltr',
        },
        style,
      ]) as TextStyle,
    [style]
  );
  return (
    <NNText className={textStyle} style={nStyle} {...props}>
      {tx ? translate(tx) : children}
    </NNText>
  );
};
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

Tip

You can also use the `t` snippet to create a simple Text with a default `className`.

**Props**

* All React Native Text Props are supported
* `className` - Tailwind CSS class names
* `tx` - Translation key

**Use Case**

```tsx
import * as React from 'react';
import { Text, View } from 'react-native';


const MyComponent = () => {
  return (
    <View className="flex flex-col items-center justify-center">
      <Text className="text-2xl" tx="welcome" />
      <Text className="text-md" className="text-base">
        Hello world
      </Text>
    </View>
  );
};
```

## Button

[Section titled â€œButtonâ€](#button)

The starter comes with a simple `Button` component that you can use to create a basic `Pressable` with a `Text` using Tailwind CSS classes and variant definitions. These variantsâ€™ logic is based on the `tailwind-variants` package.

The `tv` function from `tailwind-variants` is used to create a function that generates a styling configuration object for the Button component based on slot definitions, variant, size , disabled status, full-width, and default variants. Consequently, the `styles` defines the styles for the Button based on the provided props using the `button` function.

Each variant should include styles for the `container`, `indicator`, and `label` keys. The `container` style is for the `Pressable`, the `label` style is for the `Text` component, and the `indicator` style is for the `ActivityIndicator` component when the `loading` prop is `true`.

src/components/ui/button.tsx

```tsx
import React from 'react';
import type { PressableProps, View } from 'react-native';
import { ActivityIndicator, Pressable, Text } from 'react-native';
import type { VariantProps } from 'tailwind-variants';
import { tv } from 'tailwind-variants';


const button = tv({
  slots: {
    container: 'my-2 flex flex-row items-center justify-center rounded-md px-4',
    label: 'font-inter text-base font-semibold',
    indicator: 'h-6 text-white',
  },


  variants: {
    variant: {
      default: {
        container: 'bg-black dark:bg-white',
        label: 'text-white dark:text-black',
        indicator: 'text-white dark:text-black',
      },
      secondary: {
        container: 'bg-primary-600',
        label: 'text-secondary-600',
        indicator: 'text-white',
      },
      outline: {
        container: 'border border-neutral-400',
        label: 'text-black dark:text-neutral-100',
        indicator: 'text-black dark:text-neutral-100',
      },
      destructive: {
        container: 'bg-red-600',
        label: 'text-white',
        indicator: 'text-white',
      },
      ghost: {
        container: 'bg-transparent',
        label: 'text-black underline dark:text-white',
        indicator: 'text-black dark:text-white',
      },
      link: {
        container: 'bg-transparent',
        label: 'text-black',
        indicator: 'text-black',
      },
    },
    size: {
      default: {
        container: 'h-10 px-4',
        label: 'text-base',
      },
      lg: {
        container: 'h-12 px-8',
        label: 'text-xl',
      },
      sm: {
        container: 'h-8 px-3',
        label: 'text-sm',
        indicator: 'h-2',
      },
      icon: { container: 'size-9' },
    },
    disabled: {
      true: {
        container: 'bg-neutral-300 dark:bg-neutral-300',
        label: 'text-neutral-600 dark:text-neutral-600',
        indicator: 'text-neutral-400 dark:text-neutral-400',
      },
    },
    fullWidth: {
      true: {
        container: '',
      },
      false: {
        container: 'self-center',
      },
    },
  },
  defaultVariants: {
    variant: 'default',
    disabled: false,
    fullWidth: true,
    size: 'default',
  },
});


type ButtonVariants = VariantProps<typeof button>;
interface Props extends ButtonVariants, Omit<PressableProps, 'disabled'> {
  label?: string;
  loading?: boolean;
  className?: string;
  textClassName?: string;
}


export const Button = React.forwardRef<View, Props>(
  (
    {
      label: text,
      loading = false,
      variant = 'default',
      disabled = false,
      size = 'default',
      className = '',
      testID,
      textClassName = '',
      ...props
    },
    ref
  ) => {
    const styles = React.useMemo(
      () => button({ variant, disabled, size }),
      [variant, disabled, size]
    );


    return (
      <Pressable
        disabled={disabled || loading}
        className={styles.container({ className })}
        {...props}
        ref={ref}
        testID={testID}
      >
        {props.children ? (
          props.children
        ) : (
          <>
            {loading ? (
              <ActivityIndicator
                size="small"
                className={styles.indicator()}
                testID={testID ? `${testID}-activity-indicator` : undefined}
              />
            ) : (
              <Text
                testID={testID ? `${testID}-label` : undefined}
                className={styles.label({ className: textClassName })}
              >
                {text}
              </Text>
            )}
          </>
        )}
      </Pressable>
    );
  }
);
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

**Props**

* All React Native Pressable Props are supported.
* `variant` - Button variant, one of `variant` objects keys (default: `default`)
* `loading` - Show loading indicator (default: `false`)
* `label` - Button label
* `size` - Button size, one of variants `size` objects keys (default: `default`)
* `className` - Tailwind CSS class names to be applied to the Buttonâ€™s container
* `textClassName` - Additional styling for the Buttonâ€™s label

**Use Case**

src/components/buttons.tsx

```tsx
import React from 'react';


import { Button, View } from '@/components/ui';


import { Title } from './title';


export const Buttons = () => {
  return (
    <>
      <Title text="Buttons" />
      <View>
        <View className="flex-row flex-wrap">
          <Button label="small" size="sm" className="mr-2" />
          <Button
            label="small"
            loading
            size="sm"
            className="mr-2 min-w-[60px]"
          />
          <Button
            label="small"
            size="sm"
            variant="secondary"
            className="mr-2"
          />
          <Button label="small" size="sm" variant="outline" className="mr-2" />
          <Button
            label="small"
            size="sm"
            variant="destructive"
            className="mr-2"
          />
          <Button label="small" size="sm" variant="ghost" className="mr-2" />
          <Button label="small" size="sm" disabled className="mr-2" />
        </View>
        <Button label="Default Button" />
        <Button label="Secondary Button" variant="secondary" />
        <Button label="Outline Button" variant="outline" />
        <Button label="Destructive Button" variant="destructive" />
        <Button label="Ghost Button" variant="ghost" />
        <Button label="Button" loading={true} />
        <Button label="Button" loading={true} variant="outline" />
        <Button label="Default Button Disabled" disabled />
        <Button
          label="Secondary Button Disabled"
          disabled
          variant="secondary"
        />
      </View>
    </>
  );
};
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

## Input

[Section titled â€œInputâ€](#input)

We provide a simple `Input` component with a `Text` component for the label and a `TextInput` component for the input.

You can use it in the same way you use the `TextInput` component from React Native, but with additional props to customize the label and error styling.

The component utilizes the tv function from Tailwind Variants to define styling slots and variants for different states such as focused, error, and disabled. These styles are applied dynamically based on the componentâ€™s state and props.

We tried to keep the `Input` component as simple as possible, but you can add more functionality, such as `onFocus` and `onBlur`, or adding left and right icons to the input.

src/components/ui/input.tsx

```tsx
import * as React from 'react';
import type {
  Control,
  FieldValues,
  Path,
  RegisterOptions,
} from 'react-hook-form';
import { useController } from 'react-hook-form';
import type { TextInputProps } from 'react-native';
import {
  I18nManager,
  StyleSheet,
  TextInput as NTextInput,
  View,
} from 'react-native';
import { tv } from 'tailwind-variants';


import colors from './colors';
import { Text } from './text';


const inputTv = tv({
  slots: {
    container: 'mb-2',
    label: 'text-grey-100 mb-1 text-lg dark:text-neutral-100',
    input:
      'mt-0 rounded-xl border-[0.5px] border-neutral-300 bg-neutral-100 px-4 py-3 font-inter text-base  font-medium leading-5 dark:border-neutral-700 dark:bg-neutral-800 dark:text-white',
  },


  variants: {
    focused: {
      true: {
        input: 'border-neutral-400 dark:border-neutral-300',
      },
    },
    error: {
      true: {
        input: 'border-danger-600',
        label: 'text-danger-600 dark:text-danger-600',
      },
    },
    disabled: {
      true: {
        input: 'bg-neutral-200',
      },
    },
  },
  defaultVariants: {
    focused: false,
    error: false,
    disabled: false,
  },
});


export interface NInputProps extends TextInputProps {
  label?: string;
  disabled?: boolean;
  error?: string;
}


type TRule<T extends FieldValues> =
  | Omit<
      RegisterOptions<T>,
      'disabled' | 'valueAsNumber' | 'valueAsDate' | 'setValueAs'
    >
  | undefined;


export type RuleType<T extends FieldValues> = { [name in keyof T]: TRule<T> };
export type InputControllerType<T extends FieldValues> = {
  name: Path<T>;
  control: Control<T>;
  rules?: RuleType<T>;
};


interface ControlledInputProps<T extends FieldValues>
  extends NInputProps,
    InputControllerType<T> {}


export const Input = React.forwardRef<NTextInput, NInputProps>((props, ref) => {
  const { label, error, testID, ...inputProps } = props;
  const [isFocussed, setIsFocussed] = React.useState(false);
  const onBlur = React.useCallback(() => setIsFocussed(false), []);
  const onFocus = React.useCallback(() => setIsFocussed(true), []);


  const styles = React.useMemo(
    () =>
      inputTv({
        error: Boolean(error),
        focused: isFocussed,
        disabled: Boolean(props.disabled),
      }),
    [error, isFocussed, props.disabled]
  );


  return (
    <View className={styles.container()}>
      {label && (
        <Text
          testID={testID ? `${testID}-label` : undefined}
          className={styles.label()}
        >
          {label}
        </Text>
      )}
      <NTextInput
        testID={testID}
        ref={ref}
        placeholderTextColor={colors.neutral[400]}
        className={styles.input()}
        onBlur={onBlur}
        onFocus={onFocus}
        {...inputProps}
        style={StyleSheet.flatten([
          { writingDirection: I18nManager.isRTL ? 'rtl' : 'ltr' },
          { textAlign: I18nManager.isRTL ? 'right' : 'left' },
          inputProps.style,
        ])}
      />
      {error && (
        <Text
          testID={testID ? `${testID}-error` : undefined}
          className="text-danger-400 dark:text-danger-600 text-sm"
        >
          {error}
        </Text>
      )}
    </View>
  );
});


// only used with react-hook-form
export function ControlledInput<T extends FieldValues>(
  props: ControlledInputProps<T>
) {
  const { name, control, rules, ...inputProps } = props;


  const { field, fieldState } = useController({ control, name, rules });
  return (
    <Input
      ref={field.ref}
      autoCapitalize="none"
      onChangeText={field.onChange}
      value={(field.value as string) || ''}
      {...inputProps}
      error={fieldState.error?.message}
    />
  );
}
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

**Props**

* All React Native TextInput Props are supported
* `label` - Input label
* `error` - Input error message

We provide also a simple `ControlledInput` component that uses the `Input` component under the hood but with a `useController` hook from `react-hook-form` to make it ready to use with `react-hook-form` library.

Read more about Handling Forms [here](../forms/).

**Use Case**

```tsx
import * as React from 'react';
import { Input, View } from '@/components/ui';


const MyComponent = () => {
  return (
    <View className="flex flex-col items-center justify-center">
      <Input label="Email" error="Email is required" />
    </View>
  );
};
```

## Modal

[Section titled â€œModalâ€](#modal)

We provide a simple `Modal` component using the `@gorhom/bottom-sheet` library to display a modal at the bottom of the screen.

We opt to use a bottom sheet instead of a modal to make it more flexible and easy to use. as well as having full control over the logic and the UI.

Based on your needs, you can use the `Modal` if you donâ€™t have a fixed height for the modal content.

src/components/ui/modal.tsx

```tsx
/**
 * Modal
 * Dependencies:
 * - @gorhom/bottom-sheet.
 *
 * Props:
 * - All `BottomSheetModalProps` props.
 * - `title` (string | undefined): Optional title for the modal header.
 *
 * Usage Example:
 * import { Modal, useModal } from '@gorhom/bottom-sheet';
 *
 * function DisplayModal() {
 *   const { ref, present, dismiss } = useModal();
 *
 *   return (
 *     <View>
 *       <Modal
 *         snapPoints={['60%']} // optional
 *         title="Modal Title"
 *         ref={ref}
 *       >
 *         Modal Content
 *       </Modal>
 *     </View>
 *   );
 * }
 *
 */


import type {
  BottomSheetBackdropProps,
  BottomSheetModalProps,
} from '@gorhom/bottom-sheet';
import { BottomSheetModal, useBottomSheet } from '@gorhom/bottom-sheet';
import * as React from 'react';
import { Pressable, View } from 'react-native';
import Animated, { FadeIn, FadeOut } from 'react-native-reanimated';
import { Path, Svg } from 'react-native-svg';


import { Text } from './text';


type ModalProps = BottomSheetModalProps & {
  title?: string;
};


type ModalRef = React.ForwardedRef<BottomSheetModal>;


type ModalHeaderProps = {
  title?: string;
  dismiss: () => void;
};


export const useModal = () => {
  const ref = React.useRef<BottomSheetModal>(null);
  const present = React.useCallback((data?: any) => {
    ref.current?.present(data);
  }, []);
  const dismiss = React.useCallback(() => {
    ref.current?.dismiss();
  }, []);
  return { ref, present, dismiss };
};


export const Modal = React.forwardRef(
  (
    {
      snapPoints: _snapPoints = ['60%'],
      title,
      detached = false,
      ...props
    }: ModalProps,
    ref: ModalRef
  ) => {
    const detachedProps = React.useMemo(
      () => getDetachedProps(detached),
      [detached]
    );
    const modal = useModal();
    const snapPoints = React.useMemo(() => _snapPoints, [_snapPoints]);


    React.useImperativeHandle(
      ref,
      () => (modal.ref.current as BottomSheetModal) || null
    );


    const renderHandleComponent = React.useCallback(
      () => (
        <>
          <View className="mt-2 mb-8 h-1 w-12 self-center rounded-lg bg-gray-400 dark:bg-gray-700" />
          <ModalHeader title={title} dismiss={modal.dismiss} />
        </>
      ),
      [title, modal.dismiss]
    );


    return (
      <BottomSheetModal
        {...props}
        {...detachedProps}
        ref={modal.ref}
        index={0}
        snapPoints={snapPoints}
        backdropComponent={props.backdropComponent || renderBackdrop}
        enableDynamicSizing={false}
        handleComponent={renderHandleComponent}
      />
    );
  }
);


/**
 * Custom Backdrop
 */


const AnimatedPressable = Animated.createAnimatedComponent(Pressable);


const CustomBackdrop = ({ style }: BottomSheetBackdropProps) => {
  const { close } = useBottomSheet();
  return (
    <AnimatedPressable
      onPress={() => close()}
      entering={FadeIn.duration(50)}
      exiting={FadeOut.duration(20)}
      style={[style, { backgroundColor: 'rgba(0, 0, 0, 0.4)' }]}
    />
  );
};


export const renderBackdrop = (props: BottomSheetBackdropProps) => (
  <CustomBackdrop {...props} />
);


/**
 *
 * @param detached
 * @returns
 *
 * @description
 * In case the modal is detached, we need to add some extra props to the modal to make it look like a detached modal.
 */


const getDetachedProps = (detached: boolean) => {
  if (detached) {
    return {
      detached: true,
      bottomInset: 46,
      style: { marginHorizontal: 16, overflow: 'hidden' },
    } as Partial<BottomSheetModalProps>;
  }
  return {} as Partial<BottomSheetModalProps>;
};


/**
 * ModalHeader
 */


const ModalHeader = React.memo(({ title, dismiss }: ModalHeaderProps) => {
  return (
    <>
      {title && (
        <View className="flex-row px-2 py-4">
          <View className="size-[24px]" />
          <View className="flex-1">
            <Text className="text-center text-[16px] font-bold text-[#26313D] dark:text-white">
              {title}
            </Text>
          </View>
        </View>
      )}
      <CloseButton close={dismiss} />
    </>
  );
});


const CloseButton = ({ close }: { close: () => void }) => {
  return (
    <Pressable
      onPress={close}
      className="absolute top-3 right-3 size-[24px] items-center justify-center"
      hitSlop={{ top: 20, bottom: 20, left: 20, right: 20 }}
      accessibilityLabel="close modal"
      accessibilityRole="button"
      accessibilityHint="closes the modal"
    >
      <Svg
        className="fill-neutral-300 dark:fill-white"
        width={24}
        height={24}
        fill="none"
        viewBox="0 0 24 24"
      >
        <Path d="M18.707 6.707a1 1 0 0 0-1.414-1.414L12 10.586 6.707 5.293a1 1 0 0 0-1.414 1.414L10.586 12l-5.293 5.293a1 1 0 1 0 1.414 1.414L12 13.414l5.293 5.293a1 1 0 0 0 1.414-1.414L13.414 12l5.293-5.293Z" />
      </Svg>
    </Pressable>
  );
};
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

**Props**

* All `@gorhom/bottom-sheet` Props are supported
* `children` - Modal content
* `title`: `string` - Modal title

**Use Case**

```tsx
import * as React from 'react';
import { Modal, useModal, View, Button, Text } from '@/components/ui';


const MyComponent = () => {
  const modal = useModal();


  return (
    <View className="flex flex-col items-center justify-center">
      <Button variant="primary" label="Show Modal" onPress={modal.present} />
      <Modal ref={modal.ref} title="modal title" snapPoints={['60%']}>
        <Text>Modal Content</Text>
      </Modal>
    </View>
  );
};
```

## Select

[Section titled â€œSelectâ€](#select)

We provide a simple `Select` component using a bottom sheet with a simple List component to select an item from a list of items.

We opt to use a bottom sheet instead of a dropdown to make it more flexible and easy to use on both iOS and Android and also to minimize the number of dependencies in the starter.

The component uses the `tv` function from Tailwind Variants to define styling slots and variants for different states such as error, and disabled. These styles are applied dynamically based on the componentâ€™s state and props.

Feel free to update the component implementation to fit your need and as you keep the same Props signature for the `Select` component the component will work with our form handling solution without any changes.

src/components/ui/select.tsx

```tsx
/* eslint-disable max-lines-per-function */
import {
  type BottomSheetModal,
  useBottomSheetScrollableCreator,
} from '@gorhom/bottom-sheet';
import { FlashList } from '@shopify/flash-list';
import * as React from 'react';
import type { FieldValues } from 'react-hook-form';
import { useController } from 'react-hook-form';
import { View } from 'react-native';
import { Pressable, type PressableProps } from 'react-native';
import type { SvgProps } from 'react-native-svg';
import Svg, { Path } from 'react-native-svg';
import { tv } from 'tailwind-variants';


import colors from '@/components/ui/colors';
import { CaretDown } from '@/components/ui/icons';
import { useAppTheme } from '@/lib/contexts/app-theme-context';


import type { InputControllerType } from './input';
import { Modal, useModal } from './modal';
import { Text } from './text';


const selectTv = tv({
  slots: {
    container: 'mb-4',
    label: 'text-grey-100 mb-1 text-lg dark:text-neutral-100',
    input:
      'border-grey-50 mt-0 flex-row items-center justify-center rounded-xl border-[0.5px] p-3  dark:border-neutral-500 dark:bg-neutral-800',
    inputValue: 'dark:text-neutral-100',
  },


  variants: {
    focused: {
      true: {
        input: 'border-neutral-600',
      },
    },
    error: {
      true: {
        input: 'border-danger-600',
        label: 'text-danger-600 dark:text-danger-600',
        inputValue: 'text-danger-600',
      },
    },
    disabled: {
      true: {
        input: 'bg-neutral-200',
      },
    },
  },
  defaultVariants: {
    error: false,
    disabled: false,
  },
});


export type OptionType = { label: string; value: string | number };


type OptionsProps = {
  options: OptionType[];
  onSelect: (option: OptionType) => void;
  value?: string | number;
  testID?: string;
};


function keyExtractor(item: OptionType) {
  return `select-item-${item.value}`;
}


export const Options = React.forwardRef<BottomSheetModal, OptionsProps>(
  ({ options, onSelect, value, testID }, ref) => {
    const height = options.length * 70 + 100;
    const snapPoints = React.useMemo(() => [height], [height]);
    const { currentTheme } = useAppTheme();
    const isDark = currentTheme === 'dark';


    const renderSelectItem = React.useCallback(
      ({ item }: { item: OptionType }) => (
        <Option
          key={`select-item-${item.value}`}
          label={item.label}
          selected={value === item.value}
          onPress={() => onSelect(item)}
          testID={testID ? `${testID}-item-${item.value}` : undefined}
        />
      ),
      [onSelect, value, testID]
    );


    const BottomSheetScrollable = useBottomSheetScrollableCreator();


    return (
      <Modal
        ref={ref}
        index={0}
        snapPoints={snapPoints}
        backgroundStyle={{
          backgroundColor: isDark ? colors.neutral[800] : colors.white,
        }}
      >
        <FlashList
          data={options}
          keyExtractor={keyExtractor}
          renderItem={renderSelectItem}
          testID={testID ? `${testID}-modal` : undefined}
          renderScrollComponent={BottomSheetScrollable}
        />
      </Modal>
    );
  }
);


const Option = React.memo(
  ({
    label,
    selected = false,
    ...props
  }: PressableProps & {
    selected?: boolean;
    label: string;
  }) => {
    return (
      <Pressable
        className="flex-row items-center border-b border-neutral-300 bg-white px-3 py-2 dark:border-neutral-700 dark:bg-neutral-800"
        {...props}
      >
        <Text className="flex-1 dark:text-neutral-100">{label}</Text>
        {selected && <Check />}
      </Pressable>
    );
  }
);


export interface SelectProps {
  value?: string | number;
  label?: string;
  disabled?: boolean;
  error?: string;
  options?: OptionType[];
  onSelect?: (value: string | number) => void;
  placeholder?: string;
  testID?: string;
}
interface ControlledSelectProps<T extends FieldValues>
  extends SelectProps,
    InputControllerType<T> {}


export const Select = (props: SelectProps) => {
  const {
    label,
    value,
    error,
    options = [],
    placeholder = 'select...',
    disabled = false,
    onSelect,
    testID,
  } = props;
  const modal = useModal();


  const onSelectOption = React.useCallback(
    (option: OptionType) => {
      onSelect?.(option.value);
      modal.dismiss();
    },
    [modal, onSelect]
  );


  const styles = React.useMemo(
    () =>
      selectTv({
        error: Boolean(error),
        disabled,
      }),
    [error, disabled]
  );


  const textValue = React.useMemo(
    () =>
      value !== undefined
        ? (options?.filter((t) => t.value === value)?.[0]?.label ?? placeholder)
        : placeholder,
    [value, options, placeholder]
  );


  return (
    <>
      <View className={styles.container()}>
        {label && (
          <Text
            testID={testID ? `${testID}-label` : undefined}
            className={styles.label()}
          >
            {label}
          </Text>
        )}
        <Pressable
          className={styles.input()}
          disabled={disabled}
          onPress={modal.present}
          testID={testID ? `${testID}-trigger` : undefined}
        >
          <View className="flex-1">
            <Text className={styles.inputValue()}>{textValue}</Text>
          </View>
          <CaretDown />
        </Pressable>
        {error && (
          <Text
            testID={`${testID}-error`}
            className="text-danger-300 dark:text-danger-600 text-sm"
          >
            {error}
          </Text>
        )}
      </View>
      <Options
        testID={testID}
        ref={modal.ref}
        options={options}
        onSelect={onSelectOption}
      />
    </>
  );
};


// only used with react-hook-form
export function ControlledSelect<T extends FieldValues>(
  props: ControlledSelectProps<T>
) {
  const { name, control, rules, onSelect: onNSelect, ...selectProps } = props;


  const { field, fieldState } = useController({ control, name, rules });
  const onSelect = React.useCallback(
    (value: string | number) => {
      field.onChange(value);
      onNSelect?.(value);
    },
    [field, onNSelect]
  );
  return (
    <Select
      onSelect={onSelect}
      value={field.value}
      error={fieldState.error?.message}
      {...selectProps}
    />
  );
}


const Check = ({ ...props }: SvgProps) => (
  <Svg
    width={25}
    height={24}
    fill="none"
    viewBox="0 0 25 24"
    {...props}
    className="stroke-black dark:stroke-white"
  >
    <Path
      d="m20.256 6.75-10.5 10.5L4.506 12"
      strokeWidth={2.438}
      strokeLinecap="round"
      strokeLinejoin="round"
    />
  </Svg>
);
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

**Props**

* `label`: `string` - Input label
* `error`: `string` - Input error message
* `options` : array of `{ label: string; value: string | number }` - List of items to select from
* `value` : `string | number` - Selected item value
* `onSelect`: `(option: Option) => void;` - Callback function to handle item selection
* `placeholder`: `string`- Placeholder text
* `disabled`: `boolean` - Disable select input (default: `false`)

**Use Case**

```tsx
import * as React from 'react';


import type { Option } from '@/components/ui';
import { SelectInput, View } from '@/components/ui';


const options: Option[] = [
  { value: 'chocolate', label: 'Chocolate' },
  { value: 'strawberry', label: 'Strawberry' },
  { value: 'vanilla', label: 'Vanilla' },
];


const MyComponent = () => {
  const [value, setValue] = React.useState<string | number | undefined>();
  return (
    <View className="flex flex-col items-center justify-center">
      <Select
        label="Select"
        error="Select is required"
        options={options}
        value={value}
        onSelect={(option) => setValue(option.value)}
      />
    </View>
  );
};
```

## Controlled Select

[Section titled â€œControlled Selectâ€](#controlled-select)

We provide a simple `ControlledSelect` component that uses the `Select` component under the hood but with a `useController` hook from `react-hook-form` to make it ready to use with `react-hook-form` library.

Read more about Handling Forms [here](../forms/).

## Checkbox, Radio & Switch

[Section titled â€œCheckbox, Radio & Switchâ€](#checkbox-radio--switch)

We provide a set of three simple and customizable components including a `Checkbox`, a `Radio`, and a `Switch`, which share the same logic under the hood.

The `Checkbox`, `Switch`, and `Radio` components are very similar as they share a common structure and are supposed to handle boolean values, their primary difference being the icon they display and the associated accessibility label. Each component accepts a range of props, allowing us to customize their appearance, behavior, and accessibility features.

For handling common functionality like handling press events and accessibility states we have the `Root` component. It wraps its children in a `Pressable` component and passes along props.

Animations are applied to the icons using the `MotiView` component from the `moti` library. These animations change the appearance of the icons based on their checked state.

src/components/ui/checkbox.tsx

```tsx
import { MotiView } from 'moti';
import React, { useCallback } from 'react';
import {
  I18nManager,
  Pressable,
  type PressableProps,
  View,
} from 'react-native';
import Svg, { Path } from 'react-native-svg';


import colors from '@/components/ui/colors';


import { Text } from './text';


const SIZE = 20;
const WIDTH = 50;
const HEIGHT = 28;
const THUMB_HEIGHT = 22;
const THUMB_WIDTH = 22;
const THUMB_OFFSET = 4;


export interface RootProps extends Omit<PressableProps, 'onPress'> {
  onChange: (checked: boolean) => void;
  checked?: boolean;
  className?: string;
  accessibilityLabel: string;
}


export type IconProps = {
  checked: boolean;
};


export const Root = ({
  checked = false,
  children,
  onChange,
  disabled,
  className = '',
  ...props
}: RootProps) => {
  const handleChange = useCallback(() => {
    onChange(!checked);
  }, [onChange, checked]);


  return (
    <Pressable
      onPress={handleChange}
      className={`flex-row items-center ${className} ${
        disabled ? 'opacity-50' : ''
      }`}
      accessibilityState={{ checked }}
      disabled={disabled}
      {...props}
    >
      {children}
    </Pressable>
  );
};


type LabelProps = {
  text: string;
  className?: string;
  testID?: string;
};


const Label = ({ text, testID, className = '' }: LabelProps) => {
  return (
    <Text testID={testID} className={` ${className} pl-2`}>
      {text}
    </Text>
  );
};


export const CheckboxIcon = ({ checked = false }: IconProps) => {
  const color = checked ? colors.primary[300] : colors.charcoal[400];
  return (
    <MotiView
      style={{
        height: SIZE,
        width: SIZE,
        borderColor: color,
      }}
      className="items-center justify-center rounded-[5px] border-2"
      from={{ backgroundColor: 'transparent', borderColor: '#CCCFD6' }}
      animate={{
        backgroundColor: checked ? color : 'transparent',
        borderColor: color,
      }}
      transition={{
        backgroundColor: { type: 'timing', duration: 100 },
        borderColor: { type: 'timing', duration: 100 },
      }}
    >
      <MotiView
        from={{ opacity: 0 }}
        animate={{ opacity: checked ? 1 : 0 }}
        transition={{ opacity: { type: 'timing', duration: 100 } }}
      >
        <Svg width="24" height="24" viewBox="0 0 24 24" fill="none">
          <Path
            d="m16.726 7-.64.633c-2.207 2.212-3.878 4.047-5.955 6.158l-2.28-1.928-.69-.584L6 12.66l.683.577 2.928 2.477.633.535.591-.584c2.421-2.426 4.148-4.367 6.532-6.756l.633-.64L16.726 7Z"
            fill="#fff"
          />
        </Svg>
      </MotiView>
    </MotiView>
  );
};


const CheckboxRoot = ({ checked = false, children, ...props }: RootProps) => {
  return (
    <Root checked={checked} accessibilityRole="checkbox" {...props}>
      {children}
    </Root>
  );
};


const CheckboxBase = ({
  checked = false,
  testID,
  label,


  ...props
}: RootProps & { label?: string }) => {
  return (
    <CheckboxRoot checked={checked} testID={testID} {...props}>
      <CheckboxIcon checked={checked} />
      {label ? (
        <Label
          text={label}
          testID={testID ? `${testID}-label` : undefined}
          className="pr-2"
        />
      ) : null}
    </CheckboxRoot>
  );
};


export const Checkbox = Object.assign(CheckboxBase, {
  Icon: CheckboxIcon,
  Root: CheckboxRoot,
  Label,
});


export const RadioIcon = ({ checked = false }: IconProps) => {
  const color = checked ? colors.primary[300] : colors.charcoal[400];
  return (
    <MotiView
      style={{
        height: SIZE,
        width: SIZE,
        borderColor: color,
      }}
      className="items-center justify-center rounded-[20px] border-2 bg-transparent"
      from={{ borderColor: '#CCCFD6' }}
      animate={{
        borderColor: color,
      }}
      transition={{ borderColor: { duration: 100, type: 'timing' } }}
    >
      <MotiView
        className={`size-[10px] rounded-[10px] ${checked && 'bg-primary-300'} `}
        from={{ opacity: 0 }}
        animate={{ opacity: checked ? 1 : 0 }}
        transition={{ opacity: { duration: 50, type: 'timing' } }}
      />
    </MotiView>
  );
};


const RadioRoot = ({ checked = false, children, ...props }: RootProps) => {
  return (
    <Root checked={checked} accessibilityRole="radio" {...props}>
      {children}
    </Root>
  );
};


const RadioBase = ({
  checked = false,
  testID,
  label,
  ...props
}: RootProps & { label?: string }) => {
  return (
    <RadioRoot checked={checked} testID={testID} {...props}>
      <RadioIcon checked={checked} />
      {label ? (
        <Label text={label} testID={testID ? `${testID}-label` : undefined} />
      ) : null}
    </RadioRoot>
  );
};


export const Radio = Object.assign(RadioBase, {
  Icon: RadioIcon,
  Root: RadioRoot,
  Label,
});


export const SwitchIcon = ({ checked = false }: IconProps) => {
  const translateX = checked
    ? THUMB_OFFSET
    : WIDTH - THUMB_WIDTH - THUMB_OFFSET;


  const backgroundColor = checked ? colors.primary[300] : colors.charcoal[400];


  return (
    <View className="w-[50px] justify-center">
      <View className="overflow-hidden rounded-full">
        <View
          style={{
            width: WIDTH,
            height: HEIGHT,
            backgroundColor,
          }}
        />
      </View>
      <MotiView
        style={{
          height: THUMB_HEIGHT,
          width: THUMB_WIDTH,
          position: 'absolute',
          backgroundColor: 'white',
          borderRadius: 13,
          right: 0,
        }}
        animate={{
          translateX: I18nManager.isRTL ? translateX : -translateX,
        }}
        transition={{ translateX: { overshootClamping: true } }}
      />
    </View>
  );
};
const SwitchRoot = ({ checked = false, children, ...props }: RootProps) => {
  return (
    <Root checked={checked} accessibilityRole="switch" {...props}>
      {children}
    </Root>
  );
};


const SwitchBase = ({
  checked = false,
  testID,
  label,
  ...props
}: RootProps & { label?: string }) => {
  return (
    <SwitchRoot checked={checked} testID={testID} {...props}>
      <SwitchIcon checked={checked} />
      {label ? (
        <Label text={label} testID={testID ? `${testID}-label` : undefined} />
      ) : null}
    </SwitchRoot>
  );
};


export const Switch = Object.assign(SwitchBase, {
  Icon: SwitchIcon,
  Root: SwitchRoot,
  Label,
});
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

**Props**

* All React Native Pressable Props are supported excluding `onPress` prop
* `onChange` - (checked: boolean) => void;\` - Callback function to handle componentâ€™s state
* `checked` - `boolean`- Determines the state of the component (default:`false`)
* `label` - Componentâ€™s label
* `accessibilityLabel` - Componentâ€™s accessibility label
* `children` - Child components/elements
* `className` - Tailwind CSS class names
* `disabled`: `boolean` - Disable component (default: `false`)

**Use Case**

```tsx
import { Checkbox } from '@/components/ui';


const App = () => {
  const [checked, setChecked] = useState(false);


  return (
    <Checkbox
      checked={checked}
      onChange={setChecked}
      accessibilityLabel="accept terms of condition"
      label="I accept terms and conditions"
    />
  );
};
```

By default the component will render a label with the text you passed as label prop and clicking on the label will toggle the component as well.

For rendering a custom Checkbox, you can use the `Checkbox.Root`, `Checkbox.Icon`, and `Checkbox.Label` components.

```tsx
import { Checkbox } from '@/components/ui';


const App = () => {
  const [checked, setChecked] = useState(false);


  return (
    <Checkbox.Root
      checked={checked}
      onChange={setChecked}
      accessibilityLabel="accept terms of condition"
    >
      <Checkbox.Icon checked={checked} />
      <Checkbox.Label text="I agree to terms and conditions" />
    </Checkbox.Root>
  );
};
```

# Fonts

> How to add custom fonts to your app.

With Expo, you can load fonts dynamically using `useFont` hook from `expo-font` library. With this approach, you need to wait for the font to load before showing or hiding your splash screen.

With the last version of `expo-font` introduced with Expo 50, you can use `expo-font` as a plugin in your `app.config.js` to load fonts natively.

To add a custom font you only need to put the font file in the `assets/fonts` and update the expo config by adding the exact file path to the config like the following:

app.config.js

```js
import type { ConfigContext, ExpoConfig } from '@expo/config';


export default ({ config }: ConfigContext): ExpoConfig => ({
  ...config,
  plugins: [
    [
      'expo-font',
      {
        fonts: ['./assets/fonts/Inter.ttf'],
      },
    ],
  ],
});
```

Next, Make sure to add your new font to Tailwind CSS config to use it with `className`

tailwind.config.js

```js
const colors = require('./src/components/ui/theme/colors');


/** @type {import('tailwindcss').Config} */
module.exports = {
  // NOTE: Update this to include the paths to all of your component files.
  content: ['./src/**/*.{js,jsx,ts,tsx}'],
  presets: [require('nativewind/preset')],
  theme: {
    extend: {
      fontFamily: {
        inter: ['Inter'],
      },
      colors,
    },
  },
  plugins: [],
};
```

As we are linking font natively you need to run `expo prebuild` and then `expo ios` or `expo android` to use the new font.

More details about adding fonts with Tailwind CSS can be found in the [Nativewind documentation](https://www.nativewind.dev/v4/tailwind/typography/font-family).

# Forms

> How to handle forms with react-hook-form and controlled components.

Forms are a common feature of any application. In this section, we will show you how you can handle form the right way with the starter.

## react-hook-form

[Section titled â€œreact-hook-formâ€](#react-hook-form)

The starter uses [react-hook-form](https://react-hook-form.com/) to handle forms. It is a popular library that provides a lot of features out of the box. It is also very easy to use and integrate with React Native.

Make sure to check the [react-hook-form documentation](https://react-hook-form.com/) to learn more about how to use it.

As we mention in the components section of the documentation [here](../components/), we create a set of controlled components that are only used with react-hook-form. The starter only provides two components: `ControlledInput` and `ControlledSelect` but you can easily create other components using the same approach.

Here is the complete code of our `ControlledInput` when we use `useController` hook from react-hook-form to handle form state and validation rules:

src/components/ui/input.tsx

```tsx
import * as React from 'react';
import type {
  Control,
  FieldValues,
  Path,
  RegisterOptions,
} from 'react-hook-form';
import { useController } from 'react-hook-form';
import type { TextInputProps } from 'react-native';
import {
  I18nManager,
  StyleSheet,
  TextInput as NTextInput,
  View,
} from 'react-native';
import { tv } from 'tailwind-variants';


import colors from './colors';
import { Text } from './text';


const inputTv = tv({
  slots: {
    container: 'mb-2',
    label: 'text-grey-100 mb-1 text-lg dark:text-neutral-100',
    input:
      'mt-0 rounded-xl border-[0.5px] border-neutral-300 bg-neutral-100 px-4 py-3 font-inter text-base  font-medium leading-5 dark:border-neutral-700 dark:bg-neutral-800 dark:text-white',
  },


  variants: {
    focused: {
      true: {
        input: 'border-neutral-400 dark:border-neutral-300',
      },
    },
    error: {
      true: {
        input: 'border-danger-600',
        label: 'text-danger-600 dark:text-danger-600',
      },
    },
    disabled: {
      true: {
        input: 'bg-neutral-200',
      },
    },
  },
  defaultVariants: {
    focused: false,
    error: false,
    disabled: false,
  },
});


export interface NInputProps extends TextInputProps {
  label?: string;
  disabled?: boolean;
  error?: string;
}


type TRule<T extends FieldValues> =
  | Omit<
      RegisterOptions<T>,
      'disabled' | 'valueAsNumber' | 'valueAsDate' | 'setValueAs'
    >
  | undefined;


export type RuleType<T extends FieldValues> = { [name in keyof T]: TRule<T> };
export type InputControllerType<T extends FieldValues> = {
  name: Path<T>;
  control: Control<T>;
  rules?: RuleType<T>;
};


interface ControlledInputProps<T extends FieldValues>
  extends NInputProps,
    InputControllerType<T> {}


export const Input = React.forwardRef<NTextInput, NInputProps>((props, ref) => {
  const { label, error, testID, ...inputProps } = props;
  const [isFocussed, setIsFocussed] = React.useState(false);
  const onBlur = React.useCallback(() => setIsFocussed(false), []);
  const onFocus = React.useCallback(() => setIsFocussed(true), []);


  const styles = React.useMemo(
    () =>
      inputTv({
        error: Boolean(error),
        focused: isFocussed,
        disabled: Boolean(props.disabled),
      }),
    [error, isFocussed, props.disabled]
  );


  return (
    <View className={styles.container()}>
      {label && (
        <Text
          testID={testID ? `${testID}-label` : undefined}
          className={styles.label()}
        >
          {label}
        </Text>
      )}
      <NTextInput
        testID={testID}
        ref={ref}
        placeholderTextColor={colors.neutral[400]}
        className={styles.input()}
        onBlur={onBlur}
        onFocus={onFocus}
        {...inputProps}
        style={StyleSheet.flatten([
          { writingDirection: I18nManager.isRTL ? 'rtl' : 'ltr' },
          { textAlign: I18nManager.isRTL ? 'right' : 'left' },
          inputProps.style,
        ])}
      />
      {error && (
        <Text
          testID={testID ? `${testID}-error` : undefined}
          className="text-danger-400 dark:text-danger-600 text-sm"
        >
          {error}
        </Text>
      )}
    </View>
  );
});


// only used with react-hook-form
export function ControlledInput<T extends FieldValues>(
  props: ControlledInputProps<T>
) {
  const { name, control, rules, ...inputProps } = props;


  const { field, fieldState } = useController({ control, name, rules });
  return (
    <Input
      ref={field.ref}
      autoCapitalize="none"
      onChangeText={field.onChange}
      value={(field.value as string) || ''}
      {...inputProps}
      error={fieldState.error?.message}
    />
  );
}
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

If you want to create your own controlled component, you just need to make sure your component props type extends from `InputControllerType` the same way we are using it with `ControlledInput`. Here is another example of a Select input we create using the same approach as `ControlledInput`:

src/components/ui/select.tsx

```tsx
/* eslint-disable max-lines-per-function */
import {
  type BottomSheetModal,
  useBottomSheetScrollableCreator,
} from '@gorhom/bottom-sheet';
import { FlashList } from '@shopify/flash-list';
import * as React from 'react';
import type { FieldValues } from 'react-hook-form';
import { useController } from 'react-hook-form';
import { View } from 'react-native';
import { Pressable, type PressableProps } from 'react-native';
import type { SvgProps } from 'react-native-svg';
import Svg, { Path } from 'react-native-svg';
import { tv } from 'tailwind-variants';


import colors from '@/components/ui/colors';
import { CaretDown } from '@/components/ui/icons';
import { useAppTheme } from '@/lib/contexts/app-theme-context';


import type { InputControllerType } from './input';
import { Modal, useModal } from './modal';
import { Text } from './text';


const selectTv = tv({
  slots: {
    container: 'mb-4',
    label: 'text-grey-100 mb-1 text-lg dark:text-neutral-100',
    input:
      'border-grey-50 mt-0 flex-row items-center justify-center rounded-xl border-[0.5px] p-3  dark:border-neutral-500 dark:bg-neutral-800',
    inputValue: 'dark:text-neutral-100',
  },


  variants: {
    focused: {
      true: {
        input: 'border-neutral-600',
      },
    },
    error: {
      true: {
        input: 'border-danger-600',
        label: 'text-danger-600 dark:text-danger-600',
        inputValue: 'text-danger-600',
      },
    },
    disabled: {
      true: {
        input: 'bg-neutral-200',
      },
    },
  },
  defaultVariants: {
    error: false,
    disabled: false,
  },
});


export type OptionType = { label: string; value: string | number };


type OptionsProps = {
  options: OptionType[];
  onSelect: (option: OptionType) => void;
  value?: string | number;
  testID?: string;
};


function keyExtractor(item: OptionType) {
  return `select-item-${item.value}`;
}


export const Options = React.forwardRef<BottomSheetModal, OptionsProps>(
  ({ options, onSelect, value, testID }, ref) => {
    const height = options.length * 70 + 100;
    const snapPoints = React.useMemo(() => [height], [height]);
    const { currentTheme } = useAppTheme();
    const isDark = currentTheme === 'dark';


    const renderSelectItem = React.useCallback(
      ({ item }: { item: OptionType }) => (
        <Option
          key={`select-item-${item.value}`}
          label={item.label}
          selected={value === item.value}
          onPress={() => onSelect(item)}
          testID={testID ? `${testID}-item-${item.value}` : undefined}
        />
      ),
      [onSelect, value, testID]
    );


    const BottomSheetScrollable = useBottomSheetScrollableCreator();


    return (
      <Modal
        ref={ref}
        index={0}
        snapPoints={snapPoints}
        backgroundStyle={{
          backgroundColor: isDark ? colors.neutral[800] : colors.white,
        }}
      >
        <FlashList
          data={options}
          keyExtractor={keyExtractor}
          renderItem={renderSelectItem}
          testID={testID ? `${testID}-modal` : undefined}
          renderScrollComponent={BottomSheetScrollable}
        />
      </Modal>
    );
  }
);


const Option = React.memo(
  ({
    label,
    selected = false,
    ...props
  }: PressableProps & {
    selected?: boolean;
    label: string;
  }) => {
    return (
      <Pressable
        className="flex-row items-center border-b border-neutral-300 bg-white px-3 py-2 dark:border-neutral-700 dark:bg-neutral-800"
        {...props}
      >
        <Text className="flex-1 dark:text-neutral-100">{label}</Text>
        {selected && <Check />}
      </Pressable>
    );
  }
);


export interface SelectProps {
  value?: string | number;
  label?: string;
  disabled?: boolean;
  error?: string;
  options?: OptionType[];
  onSelect?: (value: string | number) => void;
  placeholder?: string;
  testID?: string;
}
interface ControlledSelectProps<T extends FieldValues>
  extends SelectProps,
    InputControllerType<T> {}


export const Select = (props: SelectProps) => {
  const {
    label,
    value,
    error,
    options = [],
    placeholder = 'select...',
    disabled = false,
    onSelect,
    testID,
  } = props;
  const modal = useModal();


  const onSelectOption = React.useCallback(
    (option: OptionType) => {
      onSelect?.(option.value);
      modal.dismiss();
    },
    [modal, onSelect]
  );


  const styles = React.useMemo(
    () =>
      selectTv({
        error: Boolean(error),
        disabled,
      }),
    [error, disabled]
  );


  const textValue = React.useMemo(
    () =>
      value !== undefined
        ? (options?.filter((t) => t.value === value)?.[0]?.label ?? placeholder)
        : placeholder,
    [value, options, placeholder]
  );


  return (
    <>
      <View className={styles.container()}>
        {label && (
          <Text
            testID={testID ? `${testID}-label` : undefined}
            className={styles.label()}
          >
            {label}
          </Text>
        )}
        <Pressable
          className={styles.input()}
          disabled={disabled}
          onPress={modal.present}
          testID={testID ? `${testID}-trigger` : undefined}
        >
          <View className="flex-1">
            <Text className={styles.inputValue()}>{textValue}</Text>
          </View>
          <CaretDown />
        </Pressable>
        {error && (
          <Text
            testID={`${testID}-error`}
            className="text-danger-300 dark:text-danger-600 text-sm"
          >
            {error}
          </Text>
        )}
      </View>
      <Options
        testID={testID}
        ref={modal.ref}
        options={options}
        onSelect={onSelectOption}
      />
    </>
  );
};


// only used with react-hook-form
export function ControlledSelect<T extends FieldValues>(
  props: ControlledSelectProps<T>
) {
  const { name, control, rules, onSelect: onNSelect, ...selectProps } = props;


  const { field, fieldState } = useController({ control, name, rules });
  const onSelect = React.useCallback(
    (value: string | number) => {
      field.onChange(value);
      onNSelect?.(value);
    },
    [field, onNSelect]
  );
  return (
    <Select
      onSelect={onSelect}
      value={field.value}
      error={fieldState.error?.message}
      {...selectProps}
    />
  );
}


const Check = ({ ...props }: SvgProps) => (
  <Svg
    width={25}
    height={24}
    fill="none"
    viewBox="0 0 25 24"
    {...props}
    className="stroke-black dark:stroke-white"
  >
    <Path
      d="m20.256 6.75-10.5 10.5L4.506 12"
      strokeWidth={2.438}
      strokeLinecap="round"
      strokeLinejoin="round"
    />
  </Svg>
);
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

## Use Case

[Section titled â€œUse Caseâ€](#use-case)

Letâ€™s say you want to create a form that allows the user to log in to the application. You will need to create a screen that contains the form with email and password fields, as well as a submit button. The form will need to be validated, and the data will need to be sent to the backend. Hereâ€™s how you can do it:

\*\*Step 1: Create your schema validation \*\*

The right way to validate a form is to create a schema validation. You can use any library you want but we recommend using zod as you can easily infer the types from the schema. Here is how you can create a schema validation for the login form:

```tsx
import * as z from 'zod';


const schema = z.object({
  email: z.string().email(),
  password: z.string().min(6),
});


type FormType = z.infer<typeof schema>;
```

**Step 2: Create your form component**

Now that you have your schema validation, you can easily create your login screen using react-hook-form and the controlled components we already have. Here is how you can create your login screen:

```tsx
import { zodResolver } from '@hookform/resolvers/zod';
import React from 'react';
import { useForm } from 'react-hook-form';
import * as z from 'zod';


import { useAuth } from '@/lib';
import { Button, ControlledInput, View } from '@/components/ui';


const schema = z.object({
  email: z.string().email(),
  password: z.string().min(6),
});


type FormType = z.infer<typeof schema>;


export const Login = () => {
  const { signIn } = useAuth();


  const { handleSubmit, control } = useForm<FormType>({
    resolver: zodResolver(schema),
  });


  const onSubmit = (data: FormType) => {
    console.log(data);
    signIn({ access: 'access-token', refresh: 'refresh-token' });
  };
  return (
    <View className="flex-1 justify-center p-4">
      <ControlledInput control={control} name="email" label="Email" />
      <ControlledInput
        control={control}
        name="password"
        label="Password"
        placeholder="***"
        secureTextEntry={true}
      />
      <Button
        label="Login"
        onPress={handleSubmit(onSubmit)}
        variant="primary"
      />
    </View>
  );
};
```

Done ! You have created a form with validation and typescript support.

Tip

Any Component with props that inherit from the `InputControllerType` can be used with react-hook-form. You can easily create your own controlled component using the same approach as `ControlledInput` and `ControlledSelect`.

## Handling Keyboard

[Section titled â€œHandling Keyboardâ€](#handling-keyboard)

The template comes with [`react-native-keyboard-controller`](https://kirillzyusko.github.io/react-native-keyboard-controller/) pre-installed and configured to handle the keyboard. You only need to check the [documentation](https://kirillzyusko.github.io/react-native-keyboard-controller/) and use the appropriate approach for your use case. ( note that we already added the `KeyboardProvider` to the layout in the root file)

Make sure to check the following video for more details on how to handle keyboard in react native:

# UI and Theming

> How we manage the UI and theming of the application.

How we manage the UI and theming of the application.

## Why [Tailwind CSS](https://tailwindcss.com/) ?

[Section titled â€œWhy Tailwind CSS ?â€](#why-tailwind-css)

For the past few years, we have tried multiple approaches to style our React Native apps: Stylesheet API, styled-components, restyle, and more.

Right now, we are confident that using Tailwind CSS with React Native is the right solution, especially after trying [Nativewind](https://www.nativewind.dev/v4/overview).

If you are familiar with Tailwind CSS on the web you will find it very easy to use and you can even copy past your styling from a web application and should work without issues with react native too with some minor adjustments of course.

Last but not least, Tailwind CSS was a natural choice for us, considering that most of our team members come from a web background and have had the opportunity to work with Tailwind CSS before.

Tip

If you are not familiar with Tailwind CSS, we recommend you read the [Tailwind CSS documentation](https://tailwindcss.com/docs) first.

We would also recommend playing with the [Tailwind CSS playground](https://play.tailwindcss.com/) to get a better understanding of how it works as well as practicing by building a simple web app with it before jumping into react native.

## About Nativewind

[Section titled â€œAbout Nativewindâ€](#about-nativewind)

Nativewind is a library that allows you to use Tailwind CSS with react native. Nativewind achieves this by pre-compiling the Tailwind CSS classes into react native stylesheets with a minimal runtime to selectively apply the styles.

NativeWind version 4 introduces several improvements and enhancements and provides a more efficient development experience. The transition to version 4 introduces a different approach that eliminates the need for creating and wrapping our own components with the `styled` component. Thereby, this utility-first approach simplifies the styling process by using classes and applying styles directly within JSX elements.

For more details about Nativewind you can check their [documentation](https://www.nativewind.dev/v4/overview/).

Here is an example of how your component should look like:

src/components/card.tsx

```tsx
import { Link } from 'expo-router';
import React from 'react';


import type { Post } from '@/api';
import { Image, Pressable, Text, View } from '@/components/ui';


type Props = Post;


const images = [
  'https://images.unsplash.com/photo-1489749798305-4fea3ae63d43?auto=format&fit=crop&w=800&q=80',
  'https://images.unsplash.com/photo-1564507004663-b6dfb3c824d5?auto=format&fit=crop&w=800&q=80',
  'https://images.unsplash.com/photo-1515386474292-47555758ef2e?auto=format&fit=crop&w=800&q=80',
  'https://plus.unsplash.com/premium_photo-1666815503002-5f07a44ac8fb?auto=format&fit=crop&w=800&q=80',
  'https://images.unsplash.com/photo-1587974928442-77dc3e0dba72?auto=format&fit=crop&w=800&q=80',
];


export const Card = ({ title, body, id }: Props) => {
  return (
    <Link href={`/feed/${id}`} asChild>
      <Pressable>
        <View className="m-2 overflow-hidden rounded-xl border border-neutral-300 bg-white dark:bg-neutral-900">
          <Image
            className="h-56 w-full overflow-hidden rounded-t-xl"
            contentFit="cover"
            source={{
              uri: images[Math.floor(Math.random() * images.length)],
            }}
          />


          <View className="p-2">
            <Text className="py-3 text-2xl">{title}</Text>
            <Text numberOfLines={3} className="leading-snug text-gray-600">
              {body}
            </Text>
          </View>
        </View>
      </Pressable>
    </Link>
  );
};
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

## Configuration

[Section titled â€œConfigurationâ€](#configuration)

Nativewind is the same as Tailwind CSS, it comes with a default theme and colors that you can override by creating your own theme and colors.

You need to understand that Nativewind is a library that is built on top of Tailwind CSS. Feel free to add any Tailwind CSS config that you want to use in your application such as updating colors, spacing, typography, etc.

We have created a `ui/theme` folder where you can find our custom colors that have been imported into `tailwind.config.js` and used as a theme for our demo application. You can add your own color palette and use them in your components with Tailwind class names.

You can read more about how to [configure your project with Tailwind CSS](https://tailwindcss.com/docs/configuration).

## Dark Mode

[Section titled â€œDark Modeâ€](#dark-mode)

Your browser does not support the video tag.

### Why dark mode?

[Section titled â€œWhy dark mode?â€](#why-dark-mode)

Dark mode has gained significant traction in recent years and has become an expected feature to have. By applying dark mode, it makes it easier on the eyes in low-light environments and reduces eye strain, which means more time spent on your app.

This template comes with dark mode support out of the box, and itâ€™s very easy to customize the color scheme of your app. Thanks to [tailwindcss](https://tailwindcss.com/docs/dark-mode)

### Implementation

[Section titled â€œImplementationâ€](#implementation)

Since weâ€™re using [nativewind](https://www.nativewind.dev/) (which uses Tailwind CSS under the hood) and expo-router we let them handle the application of theme, and we just take care of the colors we want. We set the colors in `ui/theme/colors.js` and we use them in our hook `useThemeConfig.tsx` to get the theme object that we pass to ThemeProvider directly. For more information check out [expo-router](https://docs.expo.dev/router/appearance/)

src/lib/contexts/app-theme-context.tsx

```tsx
import React, { createContext, useCallback, useContext, useMemo } from 'react';
import { Uniwind, useUniwind } from 'uniwind';


export type ThemeName = 'light' | 'dark';


interface AppThemeContextType {
  currentTheme: string;
  isLight: boolean;
  isDark: boolean;
  setTheme: (theme: ThemeName) => void;
  toggleTheme: () => void;
}


const AppThemeContext = createContext<AppThemeContextType | undefined>(
  undefined
);


export const AppThemeProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const { theme } = useUniwind();


  const isLight = useMemo(() => {
    return theme === 'light' || theme.endsWith('-light');
  }, [theme]);


  const isDark = useMemo(() => {
    return theme === 'dark' || theme.endsWith('-dark');
  }, [theme]);


  const setTheme = useCallback((newTheme: ThemeName) => {
    Uniwind.setTheme(newTheme);
  }, []);


  const toggleTheme = useCallback(() => {
    switch (theme) {
      case 'light':
        Uniwind.setTheme('dark');
        break;
      case 'dark':
        Uniwind.setTheme('light');
        break;
    }
  }, [theme]);


  const value = useMemo(
    () => ({
      currentTheme: theme,
      isLight,
      isDark,
      setTheme,
      toggleTheme,
    }),
    [theme, isLight, isDark, setTheme, toggleTheme]
  );


  return (
    <AppThemeContext.Provider value={value}>
      {children}
    </AppThemeContext.Provider>
  );
};


export const useAppTheme = () => {
  const context = useContext(AppThemeContext);
  if (!context) {
    throw new Error('useAppTheme must be used within AppThemeProvider');
  }
  return context;
};
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

src/app/\_layout.tsx

```tsx
// Import  global CSS file
import '../../global.css';


import {
  Inter_400Regular,
  Inter_500Medium,
  Inter_600SemiBold,
  Inter_700Bold,
  useFonts,
} from '@expo-google-fonts/inter';
import { BottomSheetModalProvider } from '@gorhom/bottom-sheet';
import { Stack } from 'expo-router';
import * as SplashScreen from 'expo-splash-screen';
import { HeroUINativeProvider } from 'heroui-native';
import React, { useCallback } from 'react';
import { KeyboardAvoidingView, StyleSheet } from 'react-native';
import FlashMessage from 'react-native-flash-message';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { KeyboardProvider } from 'react-native-keyboard-controller';
import {
  configureReanimatedLogger,
  ReanimatedLogLevel,
} from 'react-native-reanimated';


import { APIProvider } from '@/api';
import { hydrateAuth } from '@/lib';
import { AppThemeProvider } from '@/lib/contexts/app-theme-context';


export { ErrorBoundary } from 'expo-router';


configureReanimatedLogger({
  level: ReanimatedLogLevel.warn,
  strict: false,
});


export const unstable_settings = {
  initialRouteName: '(app)',
};


hydrateAuth();
// Prevent the splash screen from auto-hiding before asset loading is complete.
SplashScreen.preventAutoHideAsync();
// Set the animation options. This is optional.
SplashScreen.setOptions({
  duration: 500,
  fade: true,
});


export default function RootLayout() {
  const fonts = useFonts({
    Inter_400Regular,
    Inter_500Medium,
    Inter_600SemiBold,
    Inter_700Bold,
  });


  if (!fonts) {
    return null;
  }


  return (
    <Providers>
      <Stack>
        <Stack.Screen name="(app)" options={{ headerShown: false }} />
        <Stack.Screen name="onboarding" options={{ headerShown: false }} />
        <Stack.Screen name="login" options={{ headerShown: false }} />
      </Stack>
    </Providers>
  );
}


const Providers: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const contentWrapper = useCallback(
    (children: React.ReactNode) => (
      <KeyboardAvoidingView
        pointerEvents="box-none"
        behavior="padding"
        keyboardVerticalOffset={12}
        className="flex-1"
      >
        {children}
      </KeyboardAvoidingView>
    ),
    []
  );


  return (
    <GestureHandlerRootView style={styles.container}>
      <KeyboardProvider>
        <AppThemeProvider>
          <HeroUINativeProvider
            config={{
              toast: {
                contentWrapper,
              },
            }}
          >
            <APIProvider>
              <BottomSheetModalProvider>
                {children}
                <FlashMessage position="top" />
              </BottomSheetModalProvider>
            </APIProvider>
          </HeroUINativeProvider>
        </AppThemeProvider>
      </KeyboardProvider>
    </GestureHandlerRootView>
  );
};


const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
});
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

### How do we handle theme changes?

[Section titled â€œHow do we handle theme changes?â€](#how-do-we-handle-theme-changes)

We use the `loadSelectedTheme` function to load the theme from the storage if thereâ€™s a theme saved in the storage, otherwise, we let nativwind use the default theme (system). To set the selected theme, we use the `useSelectedTheme` hook, which sets the theme in the storage and updates the color scheme of the app.

src/lib/hooks/use-selected-theme.tsx

```tsx
import React from 'react';
import { useMMKVString } from 'react-native-mmkv';


import { type ThemeName, useAppTheme } from '../contexts/app-theme-context';
import { storage } from '../storage';


const SELECTED_THEME = 'SELECTED_THEME';


/**
 * this hooks should only be used while selecting the theme
 * This hooks will return the selected theme which is stored in MMKV
 * selectedTheme should be one of the following values 'light', 'dark'
 * don't use this hooks if you want to use it to style your component based on the theme use useAppTheme from uniwind instead
 *
 */
export const useSelectedTheme = () => {
  const { setTheme } = useAppTheme();


  const [theme, _setTheme] = useMMKVString(SELECTED_THEME, storage);


  const setSelectedTheme = React.useCallback(
    (t: ThemeName) => {
      setTheme(t);
      _setTheme(t);
    },
    [setTheme, _setTheme]
  );


  const selectedTheme = (theme ?? 'system') as ThemeName;
  return { selectedTheme, setSelectedTheme } as const;
};
```

<!-- <SCode code="console.log('Hello world!')" lang="js" /> -->

### Add dark mode for each component

[Section titled â€œAdd dark mode for each componentâ€](#add-dark-mode-for-each-component)

To add the values for the light mode, you can simply write them directly in your component class. For the dark mode, you can use the **dark:** variant.

```tsx
<View className="... border-neutral-200 dark:border-yellow-700">....</View>
```

If you want to use the style prop, you can use the `useColorScheme` hook to get the current color scheme and use it to apply the desired style. However, **in most cases, you wonâ€™t need it** as the dark: variant will do the job.

```tsx
import { useColorScheme } from 'nativewind';


const colorScheme = useColorScheme();
const style =
  colorScheme === 'dark'
    ? { backgroundColor: 'black' }
    : { backgroundColor: 'white' };
```

For more details about dark mode, you can check [tailwind](https://tailwindcss.com/docs/dark-mode) and [nativewind](https://www.nativewind.dev/core-concepts/dark-mode)